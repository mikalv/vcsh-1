\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\documentclass{article}[1994/05/24]

\title{int: A Intermediate Code Generator for Java}

\author{Michael Schaeffer}
\date{November 11, 1996}

\begin{document}


\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

	The \verb|int| phase of the compiler is the first, and most
important, synthesis phase of the compiler.  In the \verb|int|
phase, the compiler discards the code AST's of the
individual functions, and replaces them with a stylized
version of standard Java bytecode. The only remaining step
is to actually generate the class files from the final
program tree.

\section{Theory of Operation}

	Much like the \verb|sem| phase, the \verb|int| phase is built
around \verb|traverse-ast|.  The first traversal consolidates all 
function symbol tables into one root scope of the function.  In
that manner, each function will be able to create and destroy all
locals (even in nested scopes) on entry or exit. Since the
\verb|sem| phase links variable references and procedure calls to
the appropriate symbol table entry, conflicting names don't matter.
Variable references will still be resolved to the appropriate
variable.

	For code generation, each 'functional' ast node (an ast node
that  preforms some action, has a traversal function that returns a
code snippit that implements the operation of the subtree.  For 
example \verb|a + b|, with integer function paramaters a and b, 
will generate \verb|(ILOAD #0=(a...))| \verb|(ILOAD #1=(b..))| 
\verb|(ADD INT)|. Since things like code addresses and constant
pool offsets arn't known in the \verb|int| phase, links from the
instructions that need them to the appropriate ast object are
created.  That way, during the gen phase, when these values are
derived, code generation will be trivial. This code generation
traversal also frees the \verb|CODE| attribute ast's of each function.
They are no longer needed, and they clutter up the output.

\section{Intermediate Java Bytecode}

	The bytecodes generated by the \verb|int| phase are a stylized
form of Java byte code.  Unlike standard Java code, the type of the
operands are passed as a op code paramater, and not as the paramater
itself.  Secondly, binary numeric operations use operation names
from the ast, and not necessarily the JVM specificatiom.  Finally, 
operations that take pointers to either code, or a constant pool
entry, are stored with a pointer to the ast object representing the
entry.  During the address resolution phase in \verb|gen| these
pointers wil be used to derive the address. Despite these surface
changes, the intermediate code is at the same semantic level, almost
exactly, as Java Bytecode. There is a one to one correspondence between
flow control statements and data accessors.

\section{Interpreting Lisp dumps of the ast}

	Because the Lisp printer was used to print out the output
from the compiler, the results arn't as lucid as might be desired.
Since the Lisp \verb|*print-circle*| code was used, shared structure
is displayed through the use of inline 'tags'.  The first instance of
a tag will appear as \verb#n#=(...)|, meaning that the structure in the
parens is equivalent to the tag number.  Then, when that object appears
elsewhere in the parse tree, it is displayed as \verb|#n#|, indicating
that it is a pointer to the same (in memory) structure as printed before.
Since the printed byte code contains pointers to both symbols and other
byte codes, it is possible that symbols and byte codes will be printed
within bytecode operations.  The following code fragment:

\begin{verbatim}
int a, c;
boolean b;

if(c) {
   a = b;
else;
   b = a;
\end{verbatim}

compiles to the following byte code:


\begin{verbatim}

(LOAD BOOLEAN #1=(VAR-DECL
                  ((NAME . "c")
                   (UNIQUE . #:G1453)
                   (TYPE . BOOLEAN)
                   (TYPE-MODIFIERS  LOCAL))))

(CONSTANT 0)

(IF-INTEGER-EQUAL #2=(LOAD INT #3=(VAR-DECL
                                   ((NAME . "a")
                                     (UNIQUE . #:G1475)
                                     (TYPE . INT)
                                     (TYPE-MODIFIERS LOCAL)))))
(LOAD INT #4=(VAR-DECL
              ((NAME . "b")
               (UNIQUE . #:G1464)
               (TYPE . INT)
               (TYPE-MODIFIERS LOCAL))))

(STORE INT #3#)

(GOTO #5=(NOP))

#2#

(STORE INT #4#)

#5#

\end{verbatim}

It is fairly evident from this example that symbol table
entries and byte code instructions can appear within  bytecode
instructions. However, it is also clear that the generated code
works like this:

\begin{verbatim}
     load c
     constant 0
     ifequal L1
     load b
     store a
     goto L2
L1:  load a
     store b
L2:  nop
\end{verbatim}

Jump targets can be followed with the Lisp circularity markers.

\section{Differences from the Java Specification}

\begin{description}

\item[if]

	There is a sense error that needs to be corrected.
	This may also hold true for while and for.

\item[Array References]

	This feature is implemented through the \verb|sem|
	phase and I plan to implement it in the \verb|gen|
	release of \verb|int|.

\item[Operator new]

	This was not implemented as an oversight.  It will be
	implemented in the \verb|gen| release of the compiler.

\item[Static Types]

	This feature is implemented, but not type checked.
	Since type checking will require an extension of the
	type specification structure used in \verb|sem|, this
	feature has been partially subsetted out.

\item[Class inheritance]

	Inheritance is implemented. The modification to propagate
	static type information to the \verb|int| phase introduced
	a bug in the symbol table handler for inheritance.

\item[import]

	Subsetted out, as per the assignment.

\item[Threads, Exceptions, and Synchronized]

	Since import isn't implemented, these can't be
	either.

\end{description}

\section{Test Plan}

	The test plan for the \verb|int| phase of the compiler
is more rigorous than any previous phase. For each major feature
(flow control, function calls, all the kinds of variable access,
and most typex of expressions and promotions), there is a Java
source file that implements that feature individually. In this
manner, the output of individual code genrator functions can
be analyzed for correctness.  In addition there are two, larger
test cases, that include some common algorithms. These are used
to test the overall behavior of the code generator in a real world
situation. Because of these two approaches, this test plan ensures
a high degree of code coverage, without sacrificing large scale test
cases.

	For the first time in this project, the test case engine
returns performance data as well as the final ast.  For a significant
test case, the performance of the compiler is in the 10's of lines per
second.  Considering that this is an interpreted compiler, with more
emphasis placed on correctness than speed, this performance figure is
suprisingly good. Compiling the compiler will only improve performance.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}








