;;;; vcinit.scm
;;;; March 17th, 2003
;;;; Mike Schaeffer
;
; vCalc Initialization code

; 
; Set up the packages for vCalc
;


(use-package! "scheme" "vcalc")
(in-package! "vcalc")

;
; Initialize I/O to point to the correct places
;


; Thanks to the way initialization works, these are defined in system
(set-current-error-port system::*console-error-port*)
(set-current-output-port system::*console-output-port*)

;
; Initialize the types we've defined in C
;

(system::init-types)

(define *vcalc-error-object* #f)

(define (vc-warn message . args)
  (write message)
  (newline))

(define (vc-error msg . args)
  (set! *vcalc-error-object* (cons msg args))
  (message msg "Error!")
  (throw 'vcalc-error))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Configuration variable support

(define *config-variables* '())

(defmacro (defconfig varname binding)
  `(begin
     (set! *config-variables* (cons ',varname *config-variables*))
     (define ,varname ,binding)))

(defmacro (do-config-variables var . code)
  `(for-each (lambda (,var) ,@code) *config-variables*))

(define (write-config-variables port)
  (do-config-variables varname
    (let ((val (symbol-value varname)))
      (write `(set! ,varname 
		    ,(if (pair? val)
			 (list 'quote val)
			 val))
		    port)
    (newline port)
    (newline port))))

(define (write-save-state port to-startup-file?)
  (display "; vCalc 1.0 Save File\n\n" port)
  (write-config-variables port)
  (when to-startup-file?
    (write `(set-window-placement! *stack-window*
				  ,(window-placement *stack-window*))
	   port)
    (newline port)
    (newline port)

    (write `(set-window-placement! *keyhelp-window*
				  ,(window-placement *keyhelp-window*))
	   port)
    (newline port)
    (newline port)))

(define (save-state-to-file filename to-startup-file?)
  (let ((fileport (open-output-file filename)))
    (write-save-state fileport to-startup-file?)
    (close-output-file fileport)))

; !!!!! does load-state-from-file need better error handling?
(define (load-state-from-file filename)
  (catch-all
   (load filename)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Graphics utilities
;;;
;;; These functions do some common graphics stuff

(define (set-color! s c)
  (set-foreground-color! s c)
  (set-background-color! s c))

(defmacro (with-window-draw-surface w s . forms)
  `(let ((,s (window-draw-surface ,w)))
     (unwind-protect
      (lambda ()
	(draw-surface-open! ,s)
	,@forms)
      (lambda ()
	(draw-surface-close! ,s)))))

(define (make-window class parent . initargs)
  (%%%make-window class parent initargs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Geometry functions
;;;
;;; This is a system for laying out windows in a hierarchy
;;; of boxes.  

; geometry-stack
;
; The basic architecture of the geometry code is that each
; with clause pushes a geometry context onto the geometry
; stack. A geometry context contains the current bounding
; as well as a function that is used to consume space
; from the bounding box. It returns a list containing
; both the remaining space in the current bounding box
; and the space for the requested bounding box.
;
; ( ( #(<x> <y> <w> <h> )  . <consume-fn> ) ...)

(define *geometry-stack* '())

;
; with-geometry-context
;
; Pushes a new geometry context onto the geometry stack and executes
; some forms in that context, popping the context off the stack when
; done.
;

(defmacro (with-geometry-context geometry consume . forms)
  (let ((old-stack-state-sym (gensym))
	(return-val-sym (gensym)))
    `(let ((,old-stack-state-sym *geometry-stack*)
	   (,return-val-sym '()))
       (unwind-protect 
	   (lambda ()
	     (set! *geometry-stack* 
		   (cons (cons ,geometry 
			       ,consume)
			 *geometry-stack*))
	     (set! ,return-val-sym 
		   (begin 
		    ,@forms)))
	 (lambda ()
	   (set! *geometry-stack* ,old-stack-state-sym)))
       ,return-val-sym)))

;
; consume
;
; Report the consumption of some space in the current box. This calls
; the consume function in the toplevel geometry stack record. The consume
; function returns the following tuple:
;
; ( <requested-space> . <remaining-space> )
;
; The remaining space vector can be the vector passed in, but modified
; desctructively. Consume updates the toplevel geometry record either way
; and returns the requested-space vector to the caller.
;

(define (consume x y)
  (let ((consume-result ((cdar *geometry-stack*) (caar *geometry-stack*) x y)))
    (set-car! (car *geometry-stack*) (cdr consume-result))
    (car consume-result)))
;
; let-geometry
;
; Create a set of variable bindings for the current geometry context
;

(defmacro (let-geometry x y w h . forms)
  `(let ((,x (vector-ref  (caar *geometry-stack*) 0))
	 (,y (vector-ref (caar *geometry-stack*) 1))
	 (,w (vector-ref (caar *geometry-stack*) 2))
	 (,h (vector-ref (caar *geometry-stack*) 3)))
     ,@forms))

;
; current-box-height, current-box-width, current-box-y, current-box-x, 
;

; !! Investigate atom macros

(defmacro (current-box-x) 
  '(vector-ref (caar *geometry-stack*) 0))

(defmacro (current-box-y) 
  '(vector-ref (caar *geometry-stack*) 1))

(defmacro (current-box-width) 
  '(vector-ref (caar *geometry-stack*) 2))

(defmacro (current-box-height) 
  '(vector-ref (caar *geometry-stack*) 3))

; 
; (with-geometry new-geometry
;   ...)
;
; Establish a bounding box at the given location with the 
; given size. The first call to consume within this scope
; marks the entire available space as unavailable.
;

(defmacro (with-geometry new-geometry . forms)
  `(with-geometry-context ,new-geometry
       (lambda (geometry cw ch) 
	 (cons 
	  (vector 0 0 cw ch)
	  #(0 0 0 0)))
     ,@forms))

;
; (with-window-geometry window
;   ...)
;
; Establish a bounding box equivalent in size to the client
; area of the window.
;

(defmacro (with-window-geometry w . forms)
  (let ((window-size-sym (gensym))
	(x-sym (gensym))
	(y-sym (gensym)))
    `(let ((,window-size-sym (window-size ,w)))
       (let ((,x-sym (car ,window-size-sym))
	     (,y-sym (cdr ,window-size-sym)))
	 (with-geometry (vector 0 0 ,x-sym ,y-sym)
	     ,@forms)))))

;
; (with-width w
;   ...)
;
; (with-height h
;   ...)
; 
; Push a new geometry context on the stack with a given width or height. 
; The dimension not specified is copied from the current context.
;

(defmacro (with-width w c . forms)
  `(with-geometry-context 
    (consume ,w (vector-ref (caar *geometry-stack*) 3))
    ,c
    ,@forms))

(defmacro (with-height h c . forms)
  `(with-geometry-context 
    (consume (vector-ref (caar *geometry-stack*) 2) ,h)
    ,c
    ,@forms))

;
; ( with-item w h
;    ...)
;
; Creates a geometry space for an item, in the correct spot in the parent
; space
;

(defmacro (with-item w h . forms)
  `(with-geometry 
       (consume 
	,(case w 
	   ((:fill)
	    '(current-box-width))
	   ((:fill-half)
	    '(floor (/ (current-box-width) 2)))
	   (#t
	    w))
	,(case h
	   ((:fill)
	    '(current-box-height))
	   ((:fill-half)
	    '(floor (/ (current-box-height) 2)))
	   (#t
	    h)))
       ,@forms))


;
; (with-vertical-box width order
;    ...)
;
; Establish a new bounding box within the current box. The
; box is assumed to take up the entire available space
; vertically and be of the specified width. If the
; width is specified as :fill, it fills the entire
; available width. The order paramater controls the order
; in which the box is filled. The width and order paramaters
; both take effect at macroexpand time and should be assumed
; to be static after the first (and likely only) macroexpansion
; of a given form.
;

; !! Vertical boxes automatically consume all available space. For example,
; the watch box consumes the entire vertical space on the left hand side
; of the window.

(defmacro (with-vertical-box width order . forms)
  `(with-width
       ,(case width 
	  ((:fill)
	   '(current-box-width))
	  ((:fill-half)
	   '(floor (/ (current-box-width) 2)))
	  (#t
	   width))
       (lambda (g cw ch)
	 (let-geometry gx gy gw gh
		       ,(case order
			  ((:bottom-up)
			   '(cons (vector (- (+ gx gw) cw)
					  (- (+ gy gh) ch)
					  cw ch)
				  (vector gx gy  gw (- gh ch))))
			  ((:top-down)
			   '(cons (vector gx gy cw ch)
				  (vector gx (+ gy ch) gw (- gh ch))))
			  (#t
			   (error "Invalid box order" order)))))
       ,@forms))

;
; (with-horizontal-box height order
;    ...)
;
; Establish a new bounding box within the current box. The
; box is assumed to take up the entire available space
; horizontally and be of the specified height. If the
; height is specified as :fill, it fills the entire
; available height. The order paramater controls the order
; in which the box is filled. The height and order paramaters
; both take effect at macroexpand time and should be assumed
; to be static after the first (and likely only) macroexpansion
; of a given form.
;


(defmacro (with-horizontal-box height order . forms)
  `(with-height 
       ,(case height
	      ((:fill)
	       '(current-box-height))
	      ((:fill-half)
	       '(floor (/ (current-box-height) 2)))
	      (#t
	       height))
    (lambda (g cw ch)
      (let-geometry gx gy gw gh
		    ,(case order 
		      ((:right-to-left)
		       '(cons (vector (- (+ gx gw) cw)
				      (- (+ gy gh) ch)
				      cw ch)
			      (vector gx gy  (- gw cw) gh)))
		      ((:left-to-right)
		       '(cons (vector gx gy cw ch)
			      (vector (+ gx cw) gy (- gw cw) gh)))
		      (#t
		       (error "Invalid box order" order)))))
    ,@forms))



(define (draw-current-box s)
 (let-geometry 
  gx gy gw gh
  (let ((gx2 (+ gx gw))
	(gy2 (+ gy gh)))
    (draw-rectangle s gx gy gx2 gy2))))
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Formatted text
;;
;; This set of functions supports drawing of formatted text.
;; The basic syntax for formatted text is a list of the
;; following format:
;;
;; <text> := ( <format-modifier> . ( <text> ... ) )
;; <text> := <string>
;;
;; The resulting list is traversed left to right and the text
;; is placed on the drawing surface as it is encountered. 


(define *default-font* '( "Courier New" 24 ))

;
; parse-text-modifier
;
; A modifier is an atom that is used to change a text attribute:
; 
; string - adjusts the face name
; number - adjusts the face size
; symbol - If it begins with a #\!, the corresponding symbol is
;          removed from the attribute list. If it does not, the
;          symbol is added to the attribute list.
;
; parse-text-modifier verifies that a modifier is of a valid syntax
; and, in the case of a symbol, strips off the leading #\!. Symbolic
; modifiers are also transformed into a cons cell of the following 
; format:
;
; ( <remove-modifier> . <modifier> )
;

(define (parse-text-modifier m)
  (cond ((eq? m #f)  m)
        ((string? m) m)
        ((number? m) m)
        ((symbol? m) 
          (let ((symstring (symbol->string m)))
             (if (eq? (string-ref symstring 1) #\!)
                (cons #f 
                     (string->keyword
                        (string-append 
                          ":"
                          (substring symstring 
                                     2
                                     (string-length symstring)))))
               (cons #t m))))
        (#t
          (error "Invalid text style modifier in parse-modifier" m))))

;
; modify-text-description
;
; Apply one or more modifiers to a text description. This function
; recurses over a list of modifiers, using each one to rewrite a
; font description. The nested function apply-text-modifer contains
; the code that applies a single parsed modifier to a description.
;
 
(define (apply-text-modifier desc modifier)
   (let ((modifier (parse-text-modifier modifier)))
     (cond ((eq? modifier #f)
            desc)
           ((string? modifier)
            (list-set! (list-copy desc) 0 modifier))
           ((number? modifier)
            (list-set! (list-copy desc) 1 modifier))
           ((pair? modifier)
            (let ((add-sym (car modifier))
                  (sym (cdr modifier)))
                (cons (car desc)
                  (cons (cadr desc)
                    (if add-sym
                       (if (member sym (cddr desc))
                          desc
                         (cons sym (cddr desc)))
                      (delete sym (cddr desc))))))))))
;
; linearize-formatted-text
;     
; This function translates a formatted text tree, as described above,
; into a linear list of each discrete text segment. The segment list
; takes the following form:
;
; ( :linear-text ( <format> . <text> )
;    ... )
;

(define *linearize-cache* (make-vector 101 '()))
(define *linearize-cache-enabled* #t)

(define (linearize-formatted-text f-text)
  (define (linearize-formatted-text-1 f-text desc)
    (cond ((keyword? f-text)
	   (let ((str (system-string f-text)))
	     (if str
		 (list (cons desc (system-string f-text)))
		 (list (cons desc (string-append (display-to-string f-text)
						 " not found!"))))))
	  ((string? f-text)
	   (list (cons desc f-text)))
	  ((pair? f-text)
	   (let ((new-desc (apply-text-modifier desc (car f-text))))
	     (append-map! (lambda (t) (linearize-formatted-text-1 t new-desc))
			  (cdr f-text))))
	  ((null? f-text)
	   (list (cons desc "")))
	  (#t
	   (error "Invalid formatted text in linearize-formatted-text" f-text))))

  (if *linearize-cache-enabled*
      (let ((cached-result (hash-ref *linearize-cache* f-text)))
	(if (not cached-result)
	    (let ((result (cons :linear-text (linearize-formatted-text-1 f-text *default-font*))))
	      (hash-set! *linearize-cache* f-text result)
	      result)
	    cached-result))
      (cons :linear-text (linearize-formatted-text-1 f-text *default-font*))))

(define (flush-text-cache)
  (set! *linearize-cache* (make-vector 101 '())))

(define (linear-text? text)
  (and (pair? text) (eq? (car text) :linear-text)))

(define (ensure-linear-text text)
  (if (linear-text? text)
      text
      (linearize-formatted-text text)))

;
; (draw-formatted-text s x y f-text desc)
;     
; Draw formatted text on the drawing surface s. The text
; is drawn from left to right, starting at x and with the
; baseline of the text at y. 
;
; Note: for a scheme implementation of draw-linear-text, see
; VCalcGraphics.cpp 
;

(define (draw-formatted-text s x y f-text)
  (draw-linear-text s x y (cdr (ensure-linear-text f-text))))


;
; get-formatted-text-extent
;
; Retrives the extent of the given text. The extent is returned
; as a list of the following format:
;
; ( ( <height> . <width> ) . <baseline-adjust> )
;
; Note: for a scheme implementation of get-linear-text-extent,
; see VCalcGraphics.cpp 
;


(define (get-formatted-text-extent s f-text)
  (get-linear-text-extent s (cdr (ensure-linear-text f-text))))

;
; (draw-anchored-text s x y anchor text)
;
; Draw formatted text on the drawing surface <s>. The
; text is drawn from left to right. It is placed in
; such a way that the point (<x>, <y>) is at the <anchor>
; corner of a bounding box surrounding the text.
;

(define (draw-anchored-text s x y anchor f-text)
  (let ((text (ensure-linear-text f-text)))
    (let ((extent (get-formatted-text-extent s text)))
      (let ((xs (caar extent))
	    (ys (cdar extent))
	    (ba (cdr extent))
	    (xc 0)
	    (yc 0))
	(set! y (+ y (- ys ba)))
	(case anchor 
	 ((:sw)
	  (set! xc x)
	  (set! yc (- y ys)))
	 ((:s)
	  (set! xc (- x (/ xs 2)))
	  (set! yc (- y ys)))
	 ((:se)
	  (set! xc (- x xs))
	  (set! yc (- y ys)))
	 ((:w)
	  (set! xc x)
	  (set! yc (- y (/ ys 2))))
	 ((:c)
	  (set! xc (- x (/ xs 2)))
	  (set! yc (- y (/ ys 2))))
	 ((:e)
	  (set! xc (- x xs))
	  (set! yc (- y (/ ys 2))))
	 ((:nw)
	  (set! xc x)
	  (set! yc y))
	 ((:n)
	  (set! xc (- x (/ xs 2)))
	  (set! yc y))
	 ((:ne)
	  (set! xc (- x xs))
	  (set! yc y)))
	(draw-formatted-text s xc yc text)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Tag Object
;;;;
;;;; This code implements a mechanism by which arbitrary lisp
;;;; objects can be tagged with descriptive information.


(define-structure (tagged-object)
  tag
  value)

(define (tag-object value tag)
  (make-tagged-object 'value value 'tag tag))

(define (object-value object)
  (while (tagged-object? object)
    (set! object (tagged-object-value object)))
  object)

(defmacro (strip-tags! . vars)
  `(begin
     ,@(mapcar
	(lambda (var)
	  `(set! ,var (object-value ,var)))
	vars)))

;;; Data object parser
;;;
;;; We maintain a list of read functions. Each is given a crack at 
;;; the object to be parsed.

;; Procedure lists

(define *tagged-data-readers* '())

(define (add-tagged-data-reader description f)
  (unless (procedure? f)
    (error "Invalid argument to add-tagged-data-reader" f))
  (set! *tagged-data-readers* (alist-cons description f *tagged-data-readers*)))

(define (tagged-read str)
  (unless (string? str)
    (error "Invalid argument to tagged-read" str))
  (let ((parsed-result :no-data)
	(current-readers *tagged-data-readers*))
    (while (and (pair? current-readers) 
		(eq? parsed-result :no-data))
      (set! parsed-result ((cdar current-readers) str))
      (set! current-readers (cdr current-readers)))
    (when (eq? parsed-result :no-data)
      (vc-error "Invalid syntax" str))
    (list parsed-result)))

;; Display - (With failover to display-to-string)

(define (evaluate-object o)
  (type-dispatch (o)
    ((key-macro?)
     (for-each evaluate-object (key-macro-seq o)))
    ((null?)
     #t)
    ((symbol?)
     (evaluate-object (symbol-value o)))
    ((procedure?)
     (when (and (not (get-run-mode))
		(closure-prop? o :premium))
	   (vc-error "Premium features disabled in trial version"))
     (stack-apply o))
    (else
     (stack-push o))))

(define (format-object o)
  (type-dispatch (o)
    ((key-macro?)
     (list :bold (string-append "[Macro, n="
				(number->string (length (key-macro-seq o)))
				"]")))
    ((tagged-object?)
     (list #f 
	   (list :italic (list :bold (tagged-object-tag o) ": "))
	   (format-object (tagged-object-value o))))
    ((exact?)
     (string-append "#"
		    (number->string o (default-base))
		    (default-base-char)))
    ((inexact?)
     (inexact->display-string o
			      *number-precision*
			      (eq? *number-format-mode* :scientific)
			      *seperator-mode*))
    ((dataset?)
     (list :bold
	   (string-append "["
			  (let ((dimens (dataset-dimensions o)))
			    (if dimens
				(number->string dimens)
				"?"))
			  "-Dataset, n="
			  (number->string (length (dataset-points o)))
			  "]")))
    (else
     (display-to-string o))))

(define (describe-object o)
  (type-dispatch (o)
    ((keymap?)
     (list :bold (keymap-name o)))
    ((symbol?)
     (if (and (not (get-run-mode))
	      (procedure? (symbol-value o)) 
	      (closure-prop? (symbol-value o) :premium))
	 (list :italic (symbol-name o))
	 (symbol-name o)))
    (else
     "")))


;;; Tagged type dispatch
;;;
;;;
;;; (type-dispatch ( (<variable> ... ) . <list-variable> )
;;;    ( ( <tagged-type> ... )
;;;         <form> ... )
;;;    ...
;;;    ( else
;;;        <form> ... )
;;;    )
;;;
;;; A special form that executes the first case in which the specified types
;;; match the types of the objects contained in the listed variables. 

(defmacro (type-dispatch vars . cases)
  (cons 
   'cond
   (append 
    (mapcar (lambda (current-case)
	      (cons 
	       (if (eq? (car current-case) 'else)
		   #t
		   (cons 
		    'and 
		    (let ((current-vars vars)
			  (current-types (car current-case))
			  (current-predicate '()))
		      (while (pair? current-vars)
			(when (null? current-types)
			  (error "Insufficient type specifiers in type-dispatch" current-case))
			(set! current-predicate
			      (cons `(,(car current-types) ,(car current-vars))
				    current-predicate))
			(set! current-vars (cdr current-vars))
			(set! current-types (cdr current-types)))
		      (when (not (null? current-vars))
			(error "(... . <rest>) syntax unsupported in type-dispatch"))
		      current-predicate)))
	       (cdr current-case)))
	    cases)
    '((#t
       (vc-error "Invalid Type"))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; vCalc Constants

; A list of constants. Entries take the form:
;
; ( <name> <value> <unit-string>/"" <relative-error>/:exact )

(define *constant-library* 
 '(
; General
   ("Speed of light in Vacuum" 299792458 "m s-1" :exact)
   ("Magnetic constant" 12.566370614e-7 "N A-2" :exact)
   ("Electric constant" 8.854187817e-12 "F m-1" :exact)
   ("Characteristic impedance of vacuum" 376.730313461 "Ohms" :exact)
   ("Newtonian constant of gravitation (G)" 6.67310e-11 "m3 kg-1 s-2" 1.5e-3)
   ("Planck constant" 6.6260687652e-34 "J s" 7.8e-8)
   ("Planck mass" 2.176716e-8 "kg" 7.5e-4)
   ("Planck length" 1.616012e-35 "m" 7.5e-4)
   ("Planck time" 5.390640e-44 "s" 7.5e-4)

; Electromagnetic
   ("Elementary charge" 1.60217646263e-19 "C" 3.9e-8)
   ("Elementary charge" 2.41798949195e14 "A J-1" 3.9e-8)
   ("Magnetic flux quantum" 2.06783363681e-15 "Wb" 3.9e-8)
   ("Conductance quantum" 7.748091696e-5 "S" 3.7e-9)
   ("Inverse of conductance quantum" 12906.40378647 "Ohms" 3.7e-9)
   ("Josephson constant" 483597.89819e9 "Hz V-1" 3.9e-8)
   ("von Klitzing constant" 25812.80757295 "Ohms" 3.7e-9)
   ("Bohr magneton" 927.40089937e-26 "J T-1" 4.0e-8)
   ("Nuclear magneton" 5.0507831720e-27 "J T-1" 4.0e-8)

; Atomic and Nuclear, General
   ("Fine-structure constant" 7.29735253327e-3 "" 3.7e-9)
   ("Inverse fine-structure constant" 137.0359997650 "" 3.7e-9)
   ("Rydberg constant" 10973731.56854983 "m-1" 7.6e-12)
   ("Bohr radius" 0.529177208319e-10 "m" 3.7e-9)
   ("Hartree energy" 4.3597438134e-18 "J" 7.8e-8 )
   ("Hartree energy" 27.211383411 "eV" 3.9e-8)
   ("Quantum of circulation/2" 3.63694751627e-4 "m2 s-1" 7.3e-9)
   ("Quantum of circulation" 7.27389503253e-4 "m2 s-1" 7.3e-9)
   
; Atomic and Nuclear, Electroweak
   ("Fermi coupling constant" 1.166391e-5 "GeV-2" 8.6e-6)
   ("Weak mixing angle" 0.222419 "" 8.7e-3)

; Atomic and Nuclear, Electron
   ("Electron mass" 9.1093818872e-31 "kg" 7.9e-8)
   ("Electron mass energy equivalent" 8.1871041464e-14 "J" 7.9e-8)
   ("Electron mass energy equivalent" 0.51099890221 "MeV" 4.0e-8)
   ("Electron-muon mass ratio" 4.8363321015e-3 "" 3.0e-8)
   ("Electron-tau mass ratio" 2.8755547e-4 "" 1.6e-4)
   ("Electron-proton mass ratio" 5.44617023212e-4 "" 2.1e-9)
   ("Electron-neutron mass ratio" 5.43867346212e-4 "" 2.2e-9)
   ("Electron-deuteron mass ratio" 2.724437117058e-4 "" 2.1e-9)
   ("Electron-alpha particle mass ratio" 1.370933561129e-4 "" 2.1e-9)
   ("Electron charge to mass quotient" -1.75882017471e11 "C kg-1" 4.0e-8)
   ("Electron molar mass" 5.48579911012e-7 "kg mol-1" 2.1e-9)
   ("Electron Compton wavelength" 2.42631021518E-12 "m" 7.3e-9)
   ("Classical electron radius" 2.81794028531e-15 "m" 1.1e-8)
   ("Thomson cross section" 0.66524585415e-28 "m2" 2.2e-8)
   ("Electron magnetic moment" -928.47636237e-26 "J T-1" 4.0e-8)
   ("Electron magnetic moment to Bohr magneton ratio" -1.001159652186941 "" 4.1e-12)
   ("Electron magnetic moment to nuclear magneton ratio" -1.838281966039 "" 2.1e-9)
   ("Electron magnetic moment anomaly" 1.159652186941e-3 "" 3.5e-9)
   ("Electron g-factor" -2.002319304373782 "" 4.1e-12)
   ("Electron-muon magnetic moment ratio" 206.766972063 "" 3.0e-8)
   ("Electron-proton magnetic moment ratio" -658.210687566 "" 1.0e-8)
   ("Electron to shielded proton magnetic moment ratio" -658.227595471 "" 1.1e-8)
   ("Electron-neutron magnetic moment ratio" 960.9205023 "" 2.4e-7)
   ("Electron-deuteron magnetic moment ratio" -2143.92349823 "" 1.1e-8)
   ("Electron to shielded helion magnetic moment ratio" 864.05825510 "" 1.2e-8)
   ("Electron gyromagnetic ratio" 1.76085979471e11 "s-1 T-1" 4.0e-8)
   ("Electron gyromagnetic ratio" 28024.954011 "MHz T-1" 4.0e-8)
   
; Atomic and Nuclear, Muon
   ("Muon mass" 1.8835310916e-28 "kg" 8.4e-8)
   ("Muon mass energy equivalent" 1.6928333214e-11 "J" 8.4e-8)
   ("Muon mass energy equivalent" 105.658356852 "MeV" 4.9e-8)
   ("Muon-electron mass ratio" 206.768265763 "" 3.0e-8)
   ("Muon-tau mass ratio" 5.9457297e-2 "" 1.6e-4)
   ("Muon-proton mass ratio" 0.112609517334 "" 3.0e-8)
   ("Muon-neutron mass ratio" 0.112454507934 "" 3.0e-8)
   ("Muon molar mass" 0.113428916834e-3 "kg mol-1" 3.0e-8)
   ("Muon Compton wavelength" 11.7344419735e-15 "m" 2.9e-8)
   ("Muon magnetic moment" -4.4904481322e-26 "J T-1" 4.9e-8)
   ("Muon magnetic moment to Bohr magneton ratio" -4.8419708515e-3 "" 3.0e-8)
   ("Muon magnetic momentto nuclear magneton ratio" -8.8905977027 "" 3.0e-8)
   ("Muon magnetic moment anomaly" 1.1659160264e-3 "" 5.5e-7)
   ("Muon g-factor" -2.002331832013 "" 6.4e-10)
   ("Muon-proton magnetic moment ratio" -3.1833453910 "" 3.2e-8)

; Atomic and Nuclear, Tau
   ("Tau mass" 3.1678852e-27 "kg" 1.6e-4)
   ("Tau mass energy equivalent" 2.8471546e-10 "J" 1.6e-4)
   ("Tau mass energy equivalent" 1777.0529 "MeV" 1.6e-4)
   ("Tau-electron mass ratio" 3477.6057 "" 1.6e-4)
   ("Tau-muon mass ratio" 16.818827 "" 1.6e-4)
   ("Tau-proton mass ratio" 1.8939631 "" 1.6e-4)
   ("Tau-neutron mass ratio" 1.8913531 "" 1.6e-4)
   ("Tau molar mass" 1.9077431e-3 "kg mol-1" 1.6e-4)
   ("Tau Compton wavelength" 0.6977011e-15 "m" 1.6e-4)
   
; Atomic and Nuclear, Proton
   ("Proton mass" 1.6726215813E-27 "kg" 7.9e-8)
   ("Proton mass energy equivalent" 1.5032773112E-10 "J" 7.9e-8)
   ("Proton mass energy equivalent" 938.27199838 "MeV" 4.0e-8)
   ("Proton-electron mass ratio" 1836.152667539 "" 2.1e-9)
   ("Proton-muon mass ratio" 8.8802440827 "" 3.0e-8)
   ("Proton-tau mass ratio" 0.52799486 "" 1.6e-4)
   ("Proton-neutron mass ratio" 0.9986234785558 "" 5.8e-10)
   ("Proton charge to mass quotient" 9.5788340838e7 "C kg-1" 4.0e-8)
   ("Proton molar mass" 1.0072764668813e-3 "kg mol-1" 1.3e-10)
   ("Proton Compton wavelength" 1.32140984710e-15 "m" 7.6e-9)
   ("Proton magnetic moment" 1.41060663358e-26 "J T-1" 4.1e-8)
   ("Proton magnetic moment to Bohr magneton ratio" 1.52103220315e-3 "" 1.0e-8)
   ("Proton magnetic moment to nuclear magneton ratio" 2.79284733729 "" 1.0e-8)
   ("Proton g-factor" 5.58569467557 "" 1.0E-8)
   ("Proton-neutron magnetic moment ratio" -1.4598980534 "" 2.4e-7)
   ("Shielded proton magnetic moment" 1.41057039959e-26 "J T-1" 4.2e-8)
   ("Shielded proton magnetic moment-Bohr magneton ratio"  1.52099313216e-3 "" 1.1e-8)
   ("Shielded proton magnetic moment-nuclear magneton ratio" 2.79277559731 "" 1.1e-8)
   ("Proton magnetic shielding correction" 25.68715e-6 "" 5.7e-4)
   ("Proton gyromagnetic ratio" 2.6752221211e8 "s-1 T-1" 4.1e-8)
   ("Proton gyromagnetic ratio" 42.577482518 "MHz T-1" 4.1e-8)
   ("Shielded proton gyromagnetic ratio" 2.6751534111e8 "s-1 T-1" 4.2e-8)
   
; Atomic and Nuclear, Neutron
   ("Neutron mass" 1.6749271613e-27 "kg" 7.9e-8)
   ("Neutron mass energy equivalent" 1.505349461e-10 "J" 7.9e-8)
   ("Neutron mass energy equivalent" 939.56533038 "MeV" 4.0e-8)
   ("Neutron-electron mass ratio" 1838.683655040 "" 2.2e-9)
   ("Neutron-muon mass ratio" 8.8924847827 "" 3.0e-8)
   ("Neutron-tau mass ratio" 0.52872286 "" 1.6e-4)
   ("Neutron-proton mass ratio" 1.0013784188758 "" 5.8E-10)
   ("Neutron molar mass" 1.0086649157855e-3 "kg mol-1" 5.4e-10)
   ("Neutron Compton wavelength" 1.31959089810e-15 "m" 7.6e-9)
   ("Neutron magnetic moment" -0.9662364023e-26 "J T-1" 2.4e-7)
   ("Neutron magnetic moment to Bohr magneton ratio" -1.041875632e-3 "" 2.4e-7)
   ("Neutron magnetic moment to nuclear magneton ratio" -1.9130427245 "" 2.4e-7)
   ("Neutron g-factor" -3.8260854590 "" 2.4e-7)
   ("Neutron-electron magnetic moment ratio" 1.0406688225e-3 "" 2.4e-7)
   ("Neutron-proton magnetic moment ratio" -0.6849793416 "" 2.4e-7)
   ("Neutron to shielded proton magnetic moment ratio" -0.6849969416 "" 2.4e-7)
   ("Neutron gyromagnetic ratio" 1.8324718844e8 "s-1 T-1" 2.4e-7)
   
; Atomic and Nuclear, Deuteron
   ("Deuteron mass" 3.3435830926e-27 "kg" 7.9e-8)
   ("Deuteron mass energy equivalent" 3.0050626224e-10 "J" 7.9e-8)
   ("Deuteron mass energy equivalent" 1875.61276275 "MeV" 4.0e-8)
   ("Deuteron-electron mass ratio" 3670.482955078 "" 2.1e-9)
   ("Deuteron-proton mass ratio" 1.9990075008341 "" 2.0e-10)
   ("Deuteron molar mass" 2.0135532127135e-3 "kg mol-1" 1.7e-10)
   ("Deuteron magnetic moment" 0.43307345718e-26 "J T-1" 4.2E-8)
   ("Deuteron magnetic moment to Bohr magneton ratio" 0.466975455650e-3 "" 1.1e-8)
   ("Deuteron magnetic moment to nuclear magneton ratio" 0.857438228494 "" 1.1e-8)
   ("Deuteron-electron magnetic moment ratio" -4.66434553750e-4 "" 1.1e-8)
   ("Deuteron-proton magnetic moment ratio" 0.307012208345 "" 1.5e-8)
   ("Deuteron-neutron magnetic moment ratio" -0.4482065211 "" 2.4e-7)

; Atomic and Nuclear, Helion
   ("Helion mass" 5.0064117439E-27 "kg" 7.9e-8)
   ("Helion mass energy equivalent" 4.499538483e-10 "J" 7.9e-8)
   ("Helion mass energy equivalent" 2808.3913211 "MeV" 4.0e-8)
   ("Helion-electron mass ratio" 5495.88523812 "" 2.1e-9)
   ("Helion-proton mass ratio" 2.9931526585093 "" 3.1e-10)
   ("Helion molar mass" 3.0149322346986e-3 "kg mol-1" 2.8e-10)
   ("Shielded Helion magnetic moment" -1.07455296745E-26 "J T-1" 4.2e-8)
   ("Shielded Helion magnetic moment to Bohr magneton ratio" -1.15867147414e-3 "" 1.2e-8)
   ("Shielded Helion magnetic moment to nuclear magneton ratio" -2.12749771825 "" 1.2e-8)
   ("Shielded helion to proton magnetic moment ratio" -0.76176656312 "" 1.5e-8)
   ("Shielded helion to shielded proton magnetic moment ratio" -0.761786131333 "" 4.3e-9)
   ("Shielded helion gyromagnetic ratio" 2.03789476485e8 "s-1 T-1" 4.2e-8)
   
; Atomic and Nuclear, Alpha particle
   ("Alpha particle mass" 6.6446559852e-27 "kg" 7.9e-8)
   ("Alpha particle mass energy equivalent" 5.9719189747e-10 "J" 7.9e-8)
   ("Alpha particle mass energy equivalent" 3727.3790415 "MeV" 4.0e-8)
   ("Alpha particle to electron mass ratio" 7294.29950816 "" 2.1e-9)
   ("Alpha particle to proton mass ratio" 3.972599684611 "" 2.8e-10)
   ("Alpha particle molar mass" 4.001506174710e-3 "kg mol-1" 2.5e-10)
   
; Physico-Chemical
   ("Avogadro constant" 6.0221419947e23 "mol-1" 7.9e-8)
   ("Atomic mass constant" 1.6605387313e-27 "kg" 7.9e-8)
   ("Atomic mass constant energy equivalent" 1.4924177812e-10 "J" 7.9e-8)
   ("Atomic mass constant energy equivalent" 931.49401337 "MeV" 4.0e-8)
   ("Faraday constant" 96485.341539 "C mol-1" 4.0e-8)
   ("Molar Planck constant" 3.99031268930e-10 "J s mol-1" 7.6e-9)
   ("Molar Planck constant" 0.1196265649291 "J m mol-1" 7.6e-9)
   ("Molar gas constant" 8.31447215 "J mol-1 K-1" 1.7e-6)
   ("Molar volume of ideal gas (T=273.15K, P=101.325 kPa)" 22.41399639e-3 "m3 mol-1" 1.7e-6)
   ("Sackur-Tetrode constant (T=1K, P=100kPa)" -1.1517048444 "" 3.8e-6)
   ("Sackur-Tetrode constant (T=1K, P=101.325kPa)" -1.164867844 "" 3.7e-6)
   ("Stefan-Boltzmann constant" 5.67040040e-8 "W m-2 K-4" 7.0e-6)
   ("First radiation constant" 3.7417710729e-16 "W m2" 7.8e-8)
   ("First radiation constant for spectral radiance" 1.19104272293e-16 "W m2 sr-1" 7.8e-8)
   ("second radiation constant" 1.438775225e-2 "m K" 1.7e-6)
   ("Wien displacement law constant" 2.897768651e-3 "m K" 1.7e-6)))

; This operation throws away a lot of the data in the previous list of constants. It
; drops the relative error, and incorporates the units (if present) into the constant
; name. This is done to simplify the use of this list later on, since none of the other
; values are currently used.
(set! *constant-library*
      (mapcar (lambda (entry)
	     (cons (if (= (string-length (nth 2 entry)) 0)
		       (nth 0 entry)
		       (string-append (nth 0 entry)
				      " ("
				      (nth 2 entry)
				      ")"))
		   (nth 1 entry)))
	   *constant-library*))

(define (constant-library)
  (aif (choose *stack-window* *constant-library* "Constant Library" "Pick a constant")
       (cdr it)
       '()))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;; vCalc Stack 

(defconfig *stack* '())

(define (stack-push value)
   (set! *stack* (cons value *stack*)))
   
(define (stack-pop)
   (if (null? *stack*)
       #f
     (begin
       (let ((value (car *stack*)))
         (set! *stack* (cdr *stack*))
         value))))

(define (stack-ensure-arguments number)
  (if (< (length *stack*) number)
    (throw 'invalid-number-of-arguments)))

(define (stack-consume number)
  (stack-ensure-arguments number)
  (while (> number 0)
    (stack-pop)
    (set! number (- number 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
; vCalc stack-let and stack-lambda
    
;
; stack-let
;  
; stack-let binds Scheme variables with values off of the stack
;
; (stack-let ( <variable-name> ... )
;      <form> 
;      ...)
;

(defmacro (stack-let! variable-list . form-list)
  (let ((variable-count (length variable-list)))
    `(begin
        (stack-ensure-arguments ,variable-count)
        (let* ,(mapcar (lambda (var-name) 
                           (list var-name '(stack-pop)))
                        variable-list)
           ,@form-list))))
           
;
; stack-lambda, stack-define
; 
; stack-lambda is the next step past stack-let. stack-lambda
; defines a function that takes arguments off of the stack
; and leaves its result on the stack. 
;
; (stack-lambda ( <variable-name> ... )
;    <form>
;    ...)
;
; The shortcut stack-define is supported as well. It works like 
; define works to define functions

(define *no-stack-result* (gensym "no-stack-result"))

(defmacro (stack-lambda variable-list . form-list)
  `(lambda ()
     (with-stack-transaction #t
       (let ((result (stack-let! ,variable-list ,@form-list)))
         (if (eq? result *no-stack-result*)
            '()
            (stack-push result))))))
          
(defmacro (stack-define lambda-list . form-list)
   (let ((name (car lambda-list))
         (variable-list (cdr lambda-list)))
    `(define ,name (stack-lambda ,variable-list ,@form-list))))


(define (command-parameter-count fn)
  (let ((p-list (car (system:%%closure-code fn)))
	(i 0))
    (while (not (atom? p-list))
      (set! i (+ i 1))
      (set! p-list (cdr p-list)))
    i))

(define (props . ps)
  ; Do nothing - properties are extracted from the syntax tree at
  ; runtime by closure-props
  )

(define (closure-props c)
  (aif (system::%%closure-code c)
       (let ((maybe-props-clause (caddr it)))
	 (if (and (pair? maybe-props-clause)
		  (eq? 'props (car maybe-props-clause)))
	     (cdr maybe-props-clause)
	     '()))
       '()))

(define (closure-prop? c attr)
  (member attr (closure-props c)))
      
(define *last-arguments* '())

(define (stack-apply fn)
  (let ((count (command-parameter-count fn)))

    (when (< (length *stack*) count)
      (vc-error "Invalid number of arguments"))

    (let ((remaining-stack (drop *stack* count))
	  (fixed-arguments (reverse (take *stack* count))))

    (with-stack-transaction (not (closure-prop? fn :no-stack-transaction))
      (set! *stack* remaining-stack)
      (let ((retval (apply fn (append fixed-arguments remaining-stack))))
	(cond ((null? retval)
	       )
	      ((pair? retval)
	       (for-each stack-push retval))
	      (#t
	       (stack-push retval)))
	(when (not (closure-prop? fn :no-last-arguments))
	  (set! *last-arguments* fixed-arguments))
	retval)))))

(define (last-arguments) 
  (props :no-last-arguments)
  *last-arguments*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;; last-stack support
;;;
;;; This code supports a simple transaction model for stack 
;;; operations. Any block of code surrounded by a 
;;; with-stack-transaction is treated as a transaction against
;;; the stack. On entrance to the outermost transaction, a copy
;;; of the stack is pushed onto *undo-stack*.
;;;
;;; Invoking (last-stack) pushes the current stack onto *redo-stack*
;;; and pops a new stack off of *last-stack*. The redo stack is
;;; flushed whenever a new stack is pushed on *last-stack*

(defconfig *last-stack* '())
(defconfig *redo-stack* '())
(defconfig *last-stack-limit* 10)

(define *stack-transaction-level* 0)

(define (update-last-stack)
   (set! *last-stack* 
      (take (cons *stack* *last-stack*) *last-stack-limit*))
   (set! *redo-stack* '()))
    
(define (last-stack) 
  (props :no-stack-transaction)
  (when (not (null? *last-stack*))
    (set! *redo-stack* (cons *stack* *redo-stack*))
    (set! *stack* (car *last-stack*))
    (set! *last-stack* (cdr *last-stack*)))
  '())

(define (redo-stack) 
  (props :no-stack-transaction)
  (when (not (null? *redo-stack*))
    (set! *last-stack* (cons *stack* *last-stack*))
    (set! *stack* (car *redo-stack*))
    (set! *redo-stack* (cdr *redo-stack*)))
  '())

(defmacro (with-stack-transaction last-stack? . forms)
   `(let ((old-st-level *stack-transaction-level*))
      (unwind-protect
        (lambda ()
	  (when ,last-stack?
	     (if (= *stack-transaction-level* 0)
		 (update-last-stack))
	     (set! *stack-transaction-level* (+ *stack-transaction-level* 1)))
          ,@forms)
        (lambda ()
          (set! *stack-transaction-level* old-st-level)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Keyspec
;;;
;;; A keyspec is a specification of a keystroke. These functions
;;; convert between various representations of keyspecs.

;
; describe-keyspec
;
; makes a string description of a given keyspec
;

(define *keyspec-strings*
  '((:shift . "Shift-")           (:control . "Control-")   
    (:key-back . "Backspace")     (:key-return . "Return")
    (:key-tab . "Tab")            (:key-f1 . "F1")
    (:key-f2 . "F2")              (:key-f3 . "F3")
    (:key-f4 . "F4")              (:key-f5 . "F5")
    (:key-f6 . "F6")              (:key-f7 . "F7")
    (:key-f8 . "F8")              (:key-f9 . "F9")
    (:key-f10 . "F10")            (:key-f11 . "F11")
    (:key-f11 . "F11")            (:key-f12 . "F12")
    (:key-menu .  "Alt")          (:key-pause . "Pause")
    (:key-capital . "Caps-Lock")  (:key-escape . "Escape")
    (:key-prior . "PgUp")         (:key-next . "PgDn")
    (:key-home . "Home")          (:key-end . "End")
    (:key-up . "Up")              (:key-down . "Down")
    (:key-left . "Left")          (:key-right . "Right")
    (:key-space . "Space")))

(define (describe-keyspec-or-id keyspec-or-id)
  (apply string-append (append! (list "[ ")
				(mapcar (lambda (x)
					  (aif (assoc x *keyspec-strings*)
					       (cdr it)
					       (display-to-string x)))
					(ensure-keyspec keyspec-or-id))
				(list " ]"))))

           
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Keymap
;;;
;;; A keymap is a key->action binding mechanism for sequences of
;;; keystrokes.
;;;
;;; A key sequence specification is a list of key specifications


(define-structure (keymap)
  name
  bindings
  user-cache)

(define (clear-keymap-user-cache! keymap)
  (set-keymap-user-cache! keymap '()))

(define (ensure-key-id keyspec-or-id)
  (if (exact? keyspec-or-id)
      keyspec-or-id
      (keyspec->id keyspec-or-id)))

(define (ensure-keyspec keyspec-or-id)
  (cond ((exact? keyspec-or-id)
	 (id->keyspec keyspec-or-id))
	((atom? keyspec-or-id)
	 (list keyspec-or-id))
	(#t
	 (keyspec-or-id))))

;
; keymap-set!
;
; Set a keymap entry keyed by keyspec or id
;

(define (keymap-set! keymap keyspec binding binding-public?)
  (clear-keymap-user-cache! keymap)
  (set-keymap-bindings! keymap 
			(alist-cons (ensure-key-id keyspec) (cons binding binding-public?)
				    (keymap-bindings keymap)))
  keymap)


;
; keymap-ref
;
; References a keymap entry keyed by keyspec or id
; 

(define (keymap-ref keymap keyspec)
  (aif (assoc (ensure-key-id keyspec) (keymap-bindings keymap))
       (cadr it)
       #f))

;
; keymap-bind-key!
;
; Binds a key to an object, traversing an entire keymap tree
; and possibly adding nested keymaps.
;

(define (keymap-bind! current-keymap kss binding binding-public?)
  (define (keymap-bind!-1 current-keymap-1 kss-1)
    (let ((keymap-entry (keymap-ref current-keymap-1 (car kss-1))))
      (cond ((null? (cdr kss-1))
	     (keymap-set! current-keymap-1 (car kss-1) binding binding-public?)
	     keymap-entry)
	    (keymap-entry
	     (keymap-bind!-1 keymap-entry (cdr kss-1)))
	    (#t
	     (error "Cannot implicitly create keymap" kss)))))
  (keymap-bind!-1 current-keymap kss))


(define (keymap-bind-key! current-keymap kss binding . binding-public?)
  (keymap-bind! current-keymap 
		kss 
		binding 
		(if (null? binding-public?)
		    #t
		    (car binding-public?))))

(define (keymap-bind-new-keymap! current-keymap kss binding-desc)
  (keymap-bind! current-keymap 
		kss 
		(make-keymap 'name binding-desc) 
		#t))

;
; keymap-describe-binding
;
; Given a binding, return a descriptive string
;



;
; keymap-find-key
;
; Finds a key sequence binding in a keymap, returns #f
; if the key is unbound
;

(define (keymap-find-key current-keytable kss)
  (let ((keymap-entry (keymap-ref current-keytable (car kss))))
    (cond ((null? (cdr kss))                 
	   keymap-entry)
	  ((keymap? keymap-entry)
	   (keymap-find-key keymap-entry (cdr kss)))
	  (#t
	   #f))))

          
;
; keymap-map
;
; Map over all the sub bindings within a keymap 
;

(define (keymap-map fn keymap)
  (mapcar (lambda (binding-info)
	    (fn (car binding-info)    ; key-id
		(cadr binding-info)   ; binding
		(cddr binding-info))) ; binding-public?
	  (keymap-bindings keymap)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; The current key sequence

(define *current-key-sequence* '())

(define (push-key! key-info)
  (set! *current-key-sequence*
	(append *current-key-sequence* (list key-info))))


(define (reset-current-key-sequence!)
   (set! *current-key-sequence* '()))

(define (current-key-sequence)
   *current-key-sequence*)

(define (current-key-binding)
  (if (null? *current-key-sequence*)
      *global-keymap*
      (keymap-find-key *global-keymap* (mapcar car *current-key-sequence*))))
  
(define (last-keystroke)
  (last *current-key-sequence*))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; This is the beginning of "new-world math". The following code uninterns the
;;; default scheme symbols for arithmetic operations and replaces them with 
;;; symbols bound to code that operates on vcalc objects. From this point on
;;; you either are working with vcalc numbers or you're explicitly referencing
;;; the match symbols in the scheme package. 
;;;
;;; Note: these functions are, in some sense, more limited than their scheme 
;;; equivalents.  While the scheme functions sometimes take arbitrary numbers
;;; of arguments, these all take fixed numbers. This is done so that stack-apply
;;; can figure out how many values to take off of the stack by looking at the
;;; closures' lambda lists.

; Unintern the old-world math functions

(for-each unintern! '(+ - * / 
			> >= < <= = 
			sin cos tan asin acos atan
			log exp expt exp10 sqrt 
			random set-random-seed!
			quotient remainder 
			floor ceiling truncate round
			bitwise-and
			bitwise-or
			bitwise-xor
			bitwise-not
			bitwise-shift-left
			bitwise-shift-right
			bitwise-arithmatic-shift-right
			bitwise-rotate-left
			bitwise-rotate-right random set-random-seed))

;
; Basic Arithmetic
;

(define (+ x y)
  (strip-tags! x y)
  (type-dispatch (x y)
    ((number? number?)
     (scheme:+ x y))
    ((dataset? dataset?)
     (make-dataset 'points (append (dataset-points x)
				   (dataset-points y))))))
(define (- x y)
  (strip-tags! x y)
  (type-dispatch (x y)
    ((number? number?)
     (scheme:- x y))))

(define (* x y)
  (strip-tags! x y)
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:* x y))))

(define (/ x y)
  (strip-tags! x y)
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:/ x y))))

(define (chs x)
  (strip-tags! x)
  (type-dispatch (x)
    ((number?)
     ( scheme:- x))))

(define (abs x) 
  (strip-tags! x)
  (type-dispatch (x)
    ((number?) 
     ( scheme:abs x))))
;
; Number parts
;

(define (round x) 
  (strip-tags! x)
  (type-dispatch (x)
    ((number?) 
     ( scheme:round x))))

(define (truncate x) 
  (strip-tags! x)
  (type-dispatch (x)
    ((number?) 
     ( scheme:trunc x))))

(define (floor x) 
  (strip-tags! x)
  (type-dispatch (x)
    ((number?) 
     ( scheme:floor x))))

(define (ceiling x)
  (strip-tags! x) 
  (type-dispatch (x)
    ((number?) 
     ( scheme:ceil x))))

; 
; Comparisons
;

(define (> x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:> x y))))

(define (>= x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:>= x y))))

(define (< x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:< x y))))


(define (<= x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:<= x y))))

(define (= x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:= x y))))

;
; Pseudo-random number generator
;

(define (prng)
  (scheme:random))

(define (prng-seed x)
  (strip-tags! x)
  (type-dispatch (x)
    ((exact?)
     (scheme:set-random-seed x))))

;
;
; Trig
;

(define (sin x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     ( scheme:sin (to-radians x)))))

(define (cos x)
  (props :premium)
  (strip-tags! x)
  (type-dispatch (x)
    ((inexact?)
     ( scheme:cos (to-radians x)))))

(define (tan x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     ( scheme:tan (to-radians x)))))

(define (asin x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     (to-user-angle ( scheme:asin x)))))

(define (acos x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     (to-user-angle ( scheme:acos x)))))

(define (atan x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     (to-user-angle ( scheme:atan x)))))

(define (atan2 x y)
  (props :premium)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((inexact? inexact?)
     (to-user-angle ( scheme:atan x y)))))

;
; Logs and exponentiation
;
(define (sqrt x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((inexact?)
     ( scheme:sqrt x))))

(define (expt x y)
  (props :premium)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((number? number?)
     ( scheme:expt x y))))

(define (log x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((number?)
     ( scheme:log10 x))))


(define (antilog x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((number?)
     ( scheme:exp10 x))))

(define (log-e x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((number?)
     ( scheme:log x))))

(define (antilog-e x)
  (props :premium)
  (strip-tags! x) 
  (type-dispatch (x)
    ((number?)
     ( scheme:exp x))))

(define *log-2* (log 2.0))

(define (log-2 x)
  (/ (log x) *log-2*))

(define (antilog-2 x)
  (expt 2.0 x))

;
; Factorial
;
; !! factorial seems pretty lousy for negative numbers
; !! nice to have gamma-ln, gamma directly exposed to the UI
; !! Any more precision available in doubles for gamma?

(define (factorial x)
  (props :premium)
  (define (gamma x)
    (* (/ (+ (* 75122.6331530 (expt x 0))
	     (* 80916.6278952 (expt x 1))
	     (* 36308.2951477 (expt x 2))
	     (* 8687.24529705 (expt x 3))
	     (* 1168.92649479 (expt x 4))
	     (* 83.8676043424 (expt x 5))
	     (* 2.50662827511 (expt x 6)))
	  (* (+ x 0)
	     (+ x 1)
	     (+ x 2)
	     (+ x 3)
	     (+ x 4)
	     (+ x 5)
	     (+ x 6)))
       (expt (+ x 5.5)
	     (+ x 0.5))
       (exp (- (+ x 
		  5.5)))))
  (define (inexact-factorial x)
    (if (> x 0.0)
	(let ((fact 1.0))
	  (while (> x 1.0)
	    (set! fact (* fact x))
	    (set! x (- x 1.0)))
	  (if (> x 1.0)
	      (set! fact (* fact (gamma x))))
	  fact)
	(gamma (+ x 1))))
  (define (exact-factorial x)
    (when (< x 1)
      (vc-error "Invalid argument to factorial!" x))
    (let ((accum 1))
      (while (> x 1)
	(set! accum (* x accum))
	(set! x (- x 1)))
      accum))
  (type-dispatch (x)
    ((exact?)
     (exact-factorial x))
    ((inexact?)
     (inexact-factorial x))))

(define (pi-constant) *pi*)
(define (e-constant)   2.71828182845905)
(define (phi-constant) 1.61803398874989484820)

(define (percent x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((inexact? inexact?)
     (/ (* x y) 100.0))))

(define (percent-delta x y)
  (strip-tags! x y)  
  (type-dispatch (x y)
    ((inexact? inexact?)
     (* 100.0 (/ (- y x) x)))))

(define (percent-t x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((inexact? inexact?)
     (* 100.0 (/ y x)))))

(define (bitwise-and x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((exact? exact?)
     (scheme:bitwise-and x y))))



(define (bitwise-or x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((exact? exact?)
     ( scheme:bitwise-or x y))))

(define (bitwise-xor x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((exact? exact?)
     ( scheme:bitwise-xor x y))))

(define (bitwise-not x)
  (strip-tags! x) 
  (type-dispatch (x)
    ((exact?)
     ( scheme:bitwise-xor x))))

(define (bitwise-shl x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((exact? exact?)
     ( scheme:bitwise-shift-left x y))))

(define (bitwise-shr x y)
  (strip-tags! x y) 
  (type-dispatch (x y)
    ((exact? number?)
     ( scheme:bitwise-shift-right x y))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Number types (both are internal Scheme types)

;;; Exact Numbers

(add-tagged-data-reader
 "Exact Read"
 (lambda (text) 
   (if (eq? (string-ref text 0) #\#)
       (let* ((last-char-index (- (string-length text) 1))
	      (radix-char
	       ; If we only have one character, it never overrides the radix ("#d" in hex)
	       (if (= last-char-index 1)
		   #\@
		   (char-upcase (string-ref text last-char-index))))
	      (parsed-number (case radix-char 
			       ((#\H) 
				(string->number (substring text 1 last-char-index) 16))
			       ((#\D) 
				(string->number (substring text 1 last-char-index) 10))
			       ((#\O) 
				(string->number (substring text 1 last-char-index) 8))
			       ((#\B) 
				(string->number (substring text 1 last-char-index) 2))
			       (#t
				(string->number (substring text 1 (string-length text)) 
						    (default-base))))))
	 (if parsed-number 
	     parsed-number
	     :no-data))
	:no-data)))


;;; Inexact Number

(add-tagged-data-reader
 "Inexact Read"
 (lambda (text) 
   (let ((parsed-number (string->number text)))
     (if parsed-number
	 (exact->inexact parsed-number)
	 :no-data))))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;; Registers
;;;
;;; Registers are a set of n memory locations into which objects
;;; can be temporarily stored

(define *max-register* 100)

(defconfig *registers* (make-vector *max-register* 0))

(define (parse-register-number r)
  (strip-tags! r)
  (type-dispatch (r)
    ((number?)
     (when (and (scheme:< r 0)
		(scheme:> r *max-register*))
       (vc-error "Invalid register number" r))
     r)))

(define (register-store value s)
  (let ((slot (parse-register-number s)))
    (vector-set! *registers* slot value))
  '())

(define (register-recall s)
  (let ((slot (parse-register-number s)))
    (vector-ref *registers* slot)))


(define (register-evaluate s)
  (evaluate-object (register-recall s))
  '())

(define (register-exchange value s)
  (let ((slot (parse-register-number s)))
    (let ((temp (vector-ref *registers* slot)))
      (vector-set! *registers* slot value)
      temp)))        
;
; Register watch is a watch facility that displays register values
; on the primary window as they are updated
;

(defconfig *register-watch-list* '())    
  
(define (register-watch s)
  (let ((slot (parse-register-number s)))
    (unless (member slot *register-watch-list*)
      (set! *register-watch-list* (cons slot *register-watch-list*))
      (update-window *stack-window*)))
  '())

(define (register-unwatch slot)
  (let ((slot (parse-register-number s)))
    (set! *register-watch-list* (delete slot *register-watch-list*))
    (update-window *stack-window*))
  '())
  
(define (register-unwatch-all)
  (set! *register-watch-list* '())  
  '())
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Operational modes

(defconfig *default-base* :decimal)
 
(define (default-base-text)
  (case *default-base*
	((:decimal)     "DEC" )
	((:hexadecimal) "HEX")
	((:octal)       "OCT" )
	((:binary)      "BIN" )
	(#t                                "???" )))

(define (default-base-char)
  (case *default-base*
    ((:decimal)     "d" )
    ((:hexadecimal) "h")
    ((:octal)       "o" )
    ((:binary)      "b" )
    (#t                                "?" )))

(define (default-base)
  (case *default-base*
    ((:decimal)     10 )
    ((:hexadecimal) 16 )
    ((:octal)       8  )
    ((:binary)      2  )
    (#t                                10 )))

(define (set-decimal-mode)      (set! *default-base* :decimal)      '())
(define (set-hexadecimal-mode)  (set! *default-base* :hexadecimal)  '())
(define (set-octal-mode)        (set! *default-base* :octal)        '())
(define (set-binary-mode)       (set! *default-base* :binary)       '())


(defconfig *angle-mode* :degrees)

(define (to-radians angle)
  (case *angle-mode*
    ((:degrees)
     (* angle (/ *pi* 180)))
    ((:gradians)
     (* angle (/ *pi* 200)))
    ((:radians)
     angle)))

(define (to-user-angle angle)
  (case *angle-mode*
    ((:degrees)
     (/ angle (/ *pi* 180)))
    ((:gradians)
     (/ angle (/ *pi* 200)))
    ((:radians)
     angle)))

(define (angle-mode-text)
  (case *angle-mode*
    ((:degrees)  "DEG" )
    ((:gradians) "GRAD")
    ((:radians)  "RAD" )
    (#t                           "???" )))

(define (set-degree-mode)  (set! *angle-mode* :degrees)    '())
(define (set-radian-mode)  (set! *angle-mode* :radians)    '())
(define (set-gradian-mode) (set! *angle-mode* :gradians)   '())

(defconfig *seperator-mode* :us)

(define (set-no-seperator)      (set! *seperator-mode* :none) '())
(define (set-comma-seperator)   (set! *seperator-mode* :us)   '())
(define (set-period-seperator)  (set! *seperator-mode* :euro) '())

(defconfig *number-precision* 4)
(defconfig *number-format-mode* :fixed)

(define (range-check-width w)
  (cond ((> w 16) 16)
	((< w 0)  0)
	(#t w)))

(define (set-scientific-mode s) 
  (strip-tags! s)
  (type-dispatch (s)
    ((number?)
     (set! *number-precision* (range-check-width (inexact->exact s)))
     (set! *number-format-mode* :scientific)))
  '())

(define (set-fixed-mode s)
  (strip-tags! s)
  (type-dispatch (s)
    ((number?)
     (set! *number-precision* (range-check-width (inexact->exact s)))
     (set! *number-format-mode* :fixed)))
  '())

; !! We could use standard/engineering modes

(defconfig *interest-accrual-mode* :begin)

(define (interest-accrual-text)
  (case *interest-accrual-mode* 
    ((:begin)     "BEGIN" )
    ((:end  )     "END"   )
    (#t                                       "???"   )))

(define (set-beginning) 
  (props :premium)
  (set! *interest-accrual-mode* :begin))

(define (set-ending)    
  (props :premium)
  (set! *interest-accrual-mode* :end))

(define (macro-recorder-text)
  (if *recording-macro* "REC" ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Data set
;;;; 
;;;; This is the core of the statistics package. A data set is
;;;; tagged with :dataset and has data in the following format
;;;;
;;;; ( ) / ( #( <d0> ... <dn> ) ... )

(define-structure (dataset)
  points)

; For the sake of usability, all the dataset commands use a default
; dataset stored in the top of the register file. These functions
; help manage that dataset. This usability advice is courtesy of Donny.

(define (set-current-dataset! dataset)
  (register-store dataset (- *max-register* 1)))

(define (current-dataset)
  (register-recall (scheme:- *max-register* 1)))


(define (always-clear-data)
  (set-current-dataset! (make-dataset)))

(define (clear-data)
  (props :premium)
  (when (yes-or-no? "Are you sure you want to clear the current dataset?")
    (always-clear-data))
  '())

; Need to initialize the first instance of the dataset
(always-clear-data) 



(define (dataset-dimensions dataset)
  (let ((d (dataset-points dataset)))
    (cond ((null? d)
	   #f)
	  (#t
	   (length (car d))))))

(define (ensure-dataset-dimensions dataset dimens)
  (strip-tags! dimens)
  (let ((existing-dataset-dimensions (dataset-dimensions dataset)))
    (when existing-dataset-dimensions 
      (when (not (= existing-dataset-dimensions dimens))
	(vc-error (string-append "The current dataset requires "
				 (number->string existing-dataset-dimensions)
				 " dimensional data points"))))))

(define (enter-1-data x)
  (strip-tags! x)
  (let ((dataset (current-dataset)))
    (type-dispatch (x dataset)
      ((number? dataset?)
       (ensure-dataset-dimensions dataset 1)
       (set-current-dataset!
	(make-dataset 'points (cons (vector x)
				    (dataset-points dataset)))))))
  '())

(define (enter-2-data x y)
  (strip-tags! x y)
  (let ((dataset (current-dataset)))
    (type-dispatch (x y dataset)
      ((number? number? dataset?)
       (ensure-dataset-dimensions dataset 2)
       (set-current-dataset!
	(make-dataset 'points (cons (vector x y)
				    (dataset-points dataset)))))))
  '())



(define (dataset-for-each fn dataset)
  (for-each fn (dataset-points dataset)))

(define (dataset-map fn dataset)
  (make-dataset 'points 
		(mapcar fn (dataset-points dataset))))

(define (dataset-fold kons knil dataset)
  (make-dataset 'points 
		(fold kons knil (dataset-points dataset))))

(defmacro (dataset-row-let vars row . code)
  (let ((current-index 0)
	(row-sym (gensym)))
    `(let ((,row-sym ,row))
       (let ,(mapcar (lambda (variable)
		       (set! current-index (scheme:+ current-index 1))
		       `(,variable (vector-ref ,row-sym ,(scheme:- current-index 1) 0.0)))
		     vars)
       ,@code))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Statistics calculations
;;;;
;;;; Here are a set of simple 1 and 2 variable statistics


(define (apply-vector-op-2 op v1 v2)
  (let ((i 0)
	(l1 (length v1))
	(l2 (length v2)))
    (let ((vn (make-vector (min l1 l2) '())))
      (while (scheme:< i (length vn))
	(vector-set! vn i (op 
			   (vector-ref v1 i)
			   (vector-ref v2 i)))
	(set! i (scheme:+ i 1)))
      vn)))



; canonicalize-data-row converts a data row into the canonical format 
; we use for statistical manipulation.
; 
; #(x)   -> #(1 x x^2)
; #(x y) -> #(1 x x^2 y y^2 xy)
(define (canonicalize-dataset-row row)
  (case (length row) 
    ((2)
     (let ((x (vector-ref row 0))
	   (y (vector-ref row 1)))
       (vector 1 
	       x
	       (* x x)
	       y 
	       (* y y)
	       (* x y))))
    ((1)
     (let ((x (vector-ref row 0)))
       (vector 1
	       x
	       (* x x))))
    (#t
     (error "Cannot canonicalize datasets in other than 1 or 2 dimensions" row))))

(define (canonicalize-dataset dataset)
  (dataset-map canonicalize-dataset-row dataset))

(define (calculate-dataset-avgs dataset)
  (let ((x-sum 0.0)
	(y-sum 0.0)
	(count 0))
    (dataset-for-each 
     (lambda (row)
       (dataset-row-let (x y) row
	 (set! x-sum (+ x-sum x))
	 (set! y-sum (+ y-sum y))
	 (set! count (+ count 1))))
     dataset)
    (when (= count 0)
      (vc-error "Empty Dataset!" dataset))
    (case (dataset-dimensions dataset) 
      ((1)
       (vector
	(/ x-sum count)))
      ((2)
       (vector
	(/ x-sum count)
	(/ y-sum count))))))

(define (calculate-dataset-sums dataset mean-center?)
  (let ((x-sum 0.0)
	(x2-sum 0.0)
	(y-sum 0.0)
	(y2-sum 0.0)
	(xy-sum 0.0)
	(count 0))
    (dataset-row-let (x-adj y-adj) (if mean-center? 
				       (calculate-dataset-avgs dataset)
				       #(0.0 0.0))
      (dataset-for-each 
	  (lambda (row)
	    (dataset-row-let (x y) row
	      (incr! x-sum (- x x-adj))
	      (incr! x2-sum (expt (- x x-adj) 2))
	      (incr! y-sum (- y y-adj))
	      (incr! y2-sum (expt (- y y-adj) 2))
	      (incr! xy-sum (* (- x y-adj) (- y y-adj) ))
	      (incr! count)))
	dataset))
    (vector (tag-object count "n")
	    (tag-object x-sum "sum(x)")
	    (tag-object x2-sum "sum(x^2)")
	    (tag-object y-sum "sum(y)")
	    (tag-object y2-sum "sum(y^2)")
	    (tag-object xy-sum "sum(xy)"))))
	  

(define (calculate-dataset-sdevs dataset)
  (define (sdev su2 n)
    (sqrt (* (/ 1 (- n 1)) su2)))
  (dataset-row-let (count x-sum x2-sum y-sum y2-sum xy-sum) (calculate-dataset-sums dataset #t)
    (when (= count 0)
      (vc-error "Empty Dataset!" dataset))
    (case (dataset-dimensions dataset) 
      ((1)
       (vector
	(sdev x2-sum count)))
      ((2)
       (vector
	(sdev x2-sum count)
	(sdev y2-sum count))))))

(define (calculate-dataset-lr dataset)
  (unless (= (dataset-dimensions dataset 2))
    (vc-error "2 dimensional dataset expected" dataset))
  (dataset-row-let (x-mean y-mean) (calculate-dataset-avgs dataset)
    (dataset-row-let (count x-sum x2-sum y-sum y2-sum xy-sum) (calculate-dataset-sums dataset #t)
      (when (= count 0)
	(vc-error "Empty Dataset!" dataset))
      (let ((b (/ xy-sum x2-sum)))
	(vector b
		(- y-mean (* b x-mean)))))))

(define (calculate-dataset-cov dataset population?)
  (unless (= (dataset-dimensions dataset 2))
    (vc-error "2 dimensional dataset expected" dataset))
  (dataset-row-let (count x-sum x2-sum y-sum y2-sum xy-sum) (calculate-dataset-sums dataset #t)
    (when (= count 0)
      (vc-error "Empty Dataset!" dataset))
    (* (/ 1 (- count (if population? 0 1.0)))
       xy-sum)))

(define (calculate-dataset-corr dataset)
  (unless (= (dataset-dimensions dataset 2))
    (vc-error "2 dimensional dataset expected" dataset))
  (dataset-row-let (count x-sum x2-sum y-sum y2-sum xy-sum) (calculate-dataset-sums dataset #t)
    (when (= count 0)
      (vc-error "Empty Dataset!" dataset))
    (/ xy-sum
       (sqrt (* x2-sum y2-sum)))))

(define (mean-center-dataset dataset)
  (let ((mean (calculate-dataset-avgs dataset)))
    (dataset-map (lambda (row)
		   (apply-vector-op-2 - row mean))
		 dataset)))


;;; Interface functions (called by the user)

(define (data-tot)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)
       (let ((sums (calculate-dataset-sums dataset #f)))
	 (case (dataset-dimensions dataset) 
	   ((1)
	    (vector-ref sums 1))
	   ((2)
	    (list
	     (vector-ref sums 1)
	     (vector-ref sums 3)))))))))

(define (data-atot)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)
       (let ((sums (vector->list (calculate-dataset-sums dataset #f))))
	 (case (dataset-dimensions dataset) 
	   ((1)
	    (take sums 3))
	   ((2)
	    sums)))))))

(define (data-avg)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)
       (let ((avgs (calculate-dataset-avgs dataset)))
	 (vector->list avgs))))))

(define (data-sdev)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)
       (let ((sdevs (calculate-dataset-sdevs dataset)))
	 (vector->list sdevs))))))

(define (data-lr)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)
       (let ((lr-coeffs (calculate-dataset-lr dataset)))
	 (vector->list lr-coeffs))))))

(define (data-pcov)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)	 
       (calculate-dataset-cov dataset #t)))))
  
(define (data-cov)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)	 
       (calculate-dataset-cov dataset #f)))))

(define (data-corr)
  (props :premium)
  (let ((dataset (current-dataset)))
    (strip-tags! dataset)
    (type-dispatch (dataset)
      ((dataset?)	
       (unless (eq? (dataset-dimensions dataset) 2)
	 (vc-error "Determining the correlation coefficient requires a 2 dimensional data set" '()))
       (calculate-dataset-corr dataset)))))

(define (data-watch)
  (props :premium)
  (register-watch (- *max-register* 1)))

(define (data-predx slope intercept y)
  (props :premium)
  (strip-tags! slope intercept y)
  (type-dispatch (slope intercept y)
    ((inexact? inexact? inexact?)
     (list
      slope
      intercept
     (/ (- y intercept) slope)))))

(define (data-predy slope intercept x)
  (props :premium)
  (strip-tags! slope intercept x)
  (type-dispatch (slope intercept x)
    ((inexact? inexact? inexact?)
     (list
      slope
      intercept
      (+ intercept (* slope x))))))

(define (data-predx-consuming slope intercept y)
  (props :premium)
  (strip-tags! slope intercept y)
  (type-dispatch (slope intercept y)
    ((inexact? inexact? inexact?)
     (/ (- y intercept) slope))))

(define (data-predy-consuming slope intercept x)
  (props :premium)
  (strip-tags! slope intercept x)
  (type-dispatch (slope intercept x)
    ((inexact? inexact? inexact?)
     (+ intercept (* slope x)))))

; data-log-x and -y both need to construct new dataset vectors. This
; is to allow for other occurences of the dataset in the system,
; including the one certain to appear in the *last-stack* list.

(define (data-log-x dataset)
  (props :premium)
  (strip-tags! dataset)
  (type-dispatch (dataset)
    ((dataset?)	 
     (let ((dimen (dataset-dimensions dataset)))
       (dataset-map (case dimen
		      ((1)
		       (lambda (row)
			 (vector (log (vector-ref row 0)))))
		      ((2)
		       (lambda (row)
			 (vector (log (vector-ref row 0))
				 (vector-ref row 1))))
		      (#t
		       (vc-error "Empty dataset"
				 dataset)))
		    dataset)))))

(define (data-log-y dataset)
  (props :premium)
  (strip-tags! dataset)
  (type-dispatch (dataset)
    ((dataset?)	 
     (let ((dimen (dataset-dimensions dataset)))
       (unless (eq? dimen 2)
	 (vc-error "Taking the log of y requires a 2 dimensional data set" '()))
       (dataset-map (case dimen
		      ((2)
		       (lambda (row)
			 (vector (vector-ref row 0)
				 (log (vector-ref row 1)))))
		      (#t
		       (vc-error "Empty dataset"
				 dataset)))
		    dataset)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
; Basic primitives
          

(define (sclear) 
  (set! *stack* '())
  '())

(define (sdrop x) 
  ())

(define (sswap x y) 
  (list y x))

(define (sdup x) 
  (list x x))

(define (sdup2 x y) 
  (list x y x y))
	
(define (srot x y z) 
  (list y z x))

(define (srotd x y z) 
  (list z x y))

(define (sdropn n) 
  (type-dispatch (n)
    ((number?)
     (stack-consume n))))

(define (stack-cut x)
  (strip-tags! x)
  (type-dispatch (x)
    ((number?)
     (dynamic-let ((*seperator-mode* :none))
		  (copy-text-to-clipboard (format-object x)))
     '())))

(define (stack-copy x)
  (stack-cut x)
  x)

(define (stack-paste)
  (aif (get-text-from-clipboard)
    (tagged-read (string-trim-right-questions
		  (string-trim-left 
		   (string-trim-right it))))
    '()))



	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Online help logic (tip of the day and the keyboard map
;;; window)

(define (toggle-key-help)
  (let ((key-help-placement (window-placement *keyhelp-window*)))
    (if (vector-ref key-help-placement 1)
	(show-window *keyhelp-window*)
	(hide-window *keyhelp-window*)))
  '())
	 


(defconfig *tip-of-the-day-status* '(#t . 0))

(define (show-tip-of-the-day)
  (set! *tip-of-the-day-status*
	(show-tip *stack-window* *tip-of-the-day-status*)))

(define (maybe-show-tip-of-the-day)
  (when (not (car *tip-of-the-day-status*))
    (show-tip-of-the-day)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Menu operations

(define (do-config w)
  (define (get-current-config-vector)
    (vector *angle-mode*
	    *seperator-mode*
	    *number-format-mode*
	    *number-precision*
	    *interest-accrual-mode*
	    *default-base*))
  (define (set-current-config-vector vec)
    (awhen (vector-ref vec 0)
      (set! *angle-mode* it))
    (awhen (vector-ref vec 1)
      (set! *seperator-mode* it))
    (awhen (vector-ref vec 2)
      (set! *number-format-mode* it))
    (awhen (vector-ref vec 3)
      (set! *number-precision* it))
    (awhen (vector-ref vec 4)
      (set! *interest-accrual-mode* it))
    (awhen (vector-ref vec 5)
      (set! *default-base* it))
      (update-window *stack-window*))
  (let ((current-configuration (get-current-config-vector)))
    (set-current-config-vector (aif (show-config-dialog w
							current-configuration 
							set-current-config-vector)
				    it
				    current-configuration))))

(define (do-load/save-state w load-file?)
  (awhen (choose-file w load-file?)
	 (if load-file?
	     (load-state-from-file it)
	     (save-state-to-file it #f))
	 (update-window w)))

(define *vcalc-state-file* (get-user-file-path "vcalc_savestate.vcx"))

(define (save-persistant-state)
  (save-state-to-file *vcalc-state-file* #t))

(define (maybe-load-persistant-state)
  (when (file-exists? *vcalc-state-file*)
    (load-state-from-file *vcalc-state-file*)))

(define (do-quit)
  (exit-application))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; User evaluation functions

(define (evaluate o)
  (evaluate-object o)
  '())

(define (multi-evaluate o c)
  (let ((count #f))
    (type-dispatch (c)
      ((inexact?)
       (set! count (inexact->exact c)))
      ((exact?)
       (set! count c)))
    (while (> count 0)
      (evaluate o)
      (incr! count -1)))
  '())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Keyboard macros and object evaluation

(define-structure (key-macro)
  seq)

(define *recording-macro* #f)
(define *current-macro-seq* '())

; !! Come up with a more encapsulated way to calculate recordability
(define (recordable? o)
  (if (symbol? o)
      (let ((o (symbol-value o)))
	(not (closure-prop? o :not-recordable)))
      #t))

(define (interactively-evaluate-object o)
  (when (and *recording-macro*
	     (recordable? o))
    (set! *current-macro-seq*
	  (append! *current-macro-seq* (list o))))
  (evaluate-object o))

(define (begin-macro) 
  (props :not-recordable)
  (when *recording-macro*
    (vc-error "You are already recording a macro."))
  (set! *recording-macro* #t)
  (set! *current-macro-seq* '())
  '())
 
(define (end-macro) 
  (props :not-recordable)
  (unless *recording-macro*
    (vc-error "You are not recording a macro."))
  (set! *recording-macro* #f)
  (stack-push (make-key-macro 'seq *current-macro-seq*))
  (set! *current-macro-seq* '())
  '())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; vCalc Window     

(define *stack-window* #f)
(define *keyhelp-window* #f)
(define *global-keymap* #f)

; !!!!! The current problem we face is that while pressing enter during an edit
; operation will  end the current edit session, it will also be treated
; as a command to be evaluated. What should be happening is that there should
; only be one editor callback. It should decide if a key is appropriate, and
; if not, it should read-editor-text, parse the object, and do whatever's
; appropriate... I don't think we need an edit-character-test callback and
; an edit-entered callback...

(define (begin-editor-with w letter)
  (define (commit-editor-text)
    (let ((editor-text (close-editor w)))
      (with-stack-transaction #t
	(for-each interactively-evaluate-object (tagged-read editor-text)))
      (update-window w)))
  (open-editor w (character->string letter) 
	       (lambda (key-id key-desc key-num)
		 (case key-desc
		   ((:key-return)
		    (commit-editor-text)
		    #f)
		   ((:key-escape)
		    (close-editor w)
		    #f)
		   (#t
		    #t)))))


(define char-edit-pred
  (lambda (ch)
    (or (and (char-ci>=? ch #\0)
	     (char-ci<=? ch #\9))
	(and (char-ci>=? ch #\a)
	     (char-ci<=? ch #\f))
	(char-ci=? ch #\h)
	(char-ci=? ch #\o)
	(char-ci=? ch #\.)
	(char-ci=? ch #\bs))))

(define (begin-editor-with-last-keystroke) 
  (props :no-stack-transaction   
	 :not-recordable)
  (begin-editor-with *stack-window* (cadr (last-keystroke)))
  '())



(define (init-global-keymap)   
  (set! *global-keymap* (make-keymap 'name "Global Keybindings"))

  (keymap-bind-key! *global-keymap* '(#\e) 'evaluate)
  (keymap-bind-key! *global-keymap* '(#\E) 'multi-evaluate)

  (keymap-bind-new-keymap! *global-keymap* '((:control #\k)) "Keyboard Macro>>")
  (keymap-bind-key! *global-keymap* '((:control #\k) #\[) 'begin-macro)
  (keymap-bind-key! *global-keymap* '((:control #\k) #\]) 'end-macro)


  (keymap-bind-new-keymap! *global-keymap* '(#\M) "Mode >>")

  (keymap-bind-new-keymap! *global-keymap* '(#\M #\i) "Interest Accrual >>")
  (keymap-bind-key! *global-keymap* '(#\M #\i #\e) 'set-ending)
  (keymap-bind-key! *global-keymap* '(#\M #\i #\b) 'set-beginning)

  (keymap-bind-new-keymap! *global-keymap* '(#\M #\b) "Default Base >>")
  ; (keymap-bind-key! *global-keymap* '(#\M #\b #\b) 'set-binary-mode :str-base2)
  (keymap-bind-key! *global-keymap* '(#\M #\b #\o) 'set-octal-mode)
  (keymap-bind-key! *global-keymap* '(#\M #\b #\h) 'set-hexadecimal-mode)
  (keymap-bind-key! *global-keymap* '(#\M #\b #\d) 'set-decimal-mode)

  (keymap-bind-new-keymap! *global-keymap* '(#\M #\a) "Angle >>")
  (keymap-bind-key! *global-keymap* '(#\M #\a #\d) 'set-degree-mode)
  (keymap-bind-key! *global-keymap* '(#\M #\a #\r) 'set-radian-mode)
  (keymap-bind-key! *global-keymap* '(#\M #\a #\g) 'set-gradian-mode)

  (keymap-bind-new-keymap! *global-keymap* '(#\M #\n) "Number Format >>")
  (keymap-bind-key! *global-keymap* '(#\M #\n :key-space) 'set-no-seperator)
  (keymap-bind-key! *global-keymap* '(#\M #\n #\,) 'set-comma-seperator)
  (keymap-bind-key! *global-keymap* '(#\M #\n #\.) 'set-period-seperator)
  (keymap-bind-key! *global-keymap* '(#\M #\n #\s) 'set-scientific-mode)
  (keymap-bind-key! *global-keymap* '(#\M #\n #\f) 'set-fixed-mode)

  
  (keymap-bind-new-keymap! *global-keymap* '(#\k) "Constants >>")
  (keymap-bind-key! *global-keymap* '(#\k #\k) 'constant-library)
  (keymap-bind-key! *global-keymap* '(#\k #\g) 'phi-constant)
  (keymap-bind-key! *global-keymap* '(#\k #\e) 'e-constant)
  (keymap-bind-key! *global-keymap* '(#\k #\p) 'pi-constant)


  (keymap-bind-key! *global-keymap* '((:control :key-return)) 'enter-1-data)
  (keymap-bind-key! *global-keymap* '((:control :shift :key-return)) 'enter-2-data)

  (keymap-bind-new-keymap! *global-keymap* '(#\d) "Data >>")

  (keymap-bind-new-keymap! *global-keymap* '(#\d #\a) "Apply Transformation >>")
  (keymap-bind-key! *global-keymap* '(#\d #\a #\x) 'data-log-x)
  (keymap-bind-key! *global-keymap* '(#\d #\a #\y) 'data-log-y)
  
  (keymap-bind-new-keymap! *global-keymap* '(#\d #\p) "Predict >>")
  (keymap-bind-key! *global-keymap* '(#\d #\p #\x) 'data-predx)
  (keymap-bind-key! *global-keymap* '(#\d #\p #\y) 'data-predy)
  (keymap-bind-key! *global-keymap* '(#\d #\p #\X) 'data-predx-consuming #f)
  (keymap-bind-key! *global-keymap* '(#\d #\p #\Y) 'data-predy-consuming #f)
  
  (keymap-bind-key! *global-keymap* '(#\d #\w) 'data-watch)
  (keymap-bind-key! *global-keymap* '(#\d #\V) 'data-pcov)
  (keymap-bind-key! *global-keymap* '(#\d #\v) 'data-cov)
  (keymap-bind-key! *global-keymap* '(#\d #\c) 'data-corr)
  (keymap-bind-key! *global-keymap* '(#\d #\l) 'data-lr)
  (keymap-bind-key! *global-keymap* '(#\d #\s) 'data-sdev)
  (keymap-bind-key! *global-keymap* '(#\d #\m) 'data-avg)
  (keymap-bind-key! *global-keymap* '(#\d #\t) 'data-tot)
  (keymap-bind-key! *global-keymap* '(#\d #\T) 'data-atot)
  (keymap-bind-key! *global-keymap* '(#\d #\D) 'clear-data)
  
  (keymap-bind-new-keymap! *global-keymap* '(#\n) "Number >>")
  (keymap-bind-key! *global-keymap* '(#\n #\r) 'round)
  (keymap-bind-key! *global-keymap* '(#\n #\t) 'trunc)
  (keymap-bind-key! *global-keymap* '(#\n #\f) 'floor)
  (keymap-bind-key! *global-keymap* '(#\n #\c) 'ceiling)
  (keymap-bind-key! *global-keymap* '(#\n #\a) 'abs)
  (keymap-bind-key! *global-keymap* '(#\n #\p) 'prng)
  (keymap-bind-key! *global-keymap* '(#\n #\P) 'prng-seed)
    
  (when #f ; Disabled, this doesn't work
    (keymap-bind-new-keymap! *global-keymap* '(#\t) "Time-Value of Money >>")

    (keymap-bind-key! *global-keymap* '(#\t #\T) 'tvm-solve-pmt "Solve PMT")
    (keymap-bind-key! *global-keymap* '(#\t #\t) 'tvm-set-pmt "PMT")
    (keymap-bind-key! *global-keymap* '(#\t #\I) 'tvm-solve-i "Solve i")
    (keymap-bind-key! *global-keymap* '(#\t #\i) 'tvm-set-i "i")
    (keymap-bind-key! *global-keymap* '(#\t #\N) 'tvm-solve-n "Solve n")
    (keymap-bind-key! *global-keymap* '(#\t #\n) 'tvm-set-n "n")
    (keymap-bind-key! *global-keymap* '(#\t #\F) 'tvm-solve-fv "Solve FV")
    (keymap-bind-key! *global-keymap* '(#\t #\f) 'tvm-set-fv "FV")
    (keymap-bind-key! *global-keymap* '(#\t #\P) 'tvm-solve-pv "Solve PV")
    (keymap-bind-key! *global-keymap* '(#\t #\p) 'tvm-set-pv "PV"))
  
  (keymap-bind-new-keymap! *global-keymap* '(#\m) "Math >>")
  (keymap-bind-key! *global-keymap* '(#\m (:control #\T)) 'atan2)
  (keymap-bind-key! *global-keymap* '(#\m #\S) 'asin)
  (keymap-bind-key! *global-keymap* '(#\m #\C) 'acos)
  (keymap-bind-key! *global-keymap* '(#\m #\T) 'atan)
  (keymap-bind-key! *global-keymap* '(#\m #\s) 'sin)
  (keymap-bind-key! *global-keymap* '(#\m #\c) 'cos)
  (keymap-bind-key! *global-keymap* '(#\m #\t) 'tan)
  (keymap-bind-key! *global-keymap* '(#\m #\l) 'log)
  (keymap-bind-key! *global-keymap* '(#\m #\L) 'antilog)
  
  (keymap-bind-new-keymap! *global-keymap* '(#\m #\e) "Base-e- >>")
  (keymap-bind-key! *global-keymap* '(#\m #\e #\l) 'log-e)
  (keymap-bind-key! *global-keymap* '(#\m #\e #\L) 'antilog-e)
   
  (keymap-bind-new-keymap! *global-keymap* '(#\m #\2) "Base-2- >>")
  (keymap-bind-key! *global-keymap* '(#\m #\2 #\l) 'log-2)
  (keymap-bind-key! *global-keymap* '(#\m #\2 #\L) 'antilog-2)

  (keymap-bind-key! *global-keymap* '(#\m #\!) 'factorial)

  (keymap-bind-new-keymap! *global-keymap* '(#\m #\%) "% >>")
  (keymap-bind-key! *global-keymap* '(#\m #\% #\%) 'percent)
  (keymap-bind-key! *global-keymap* '(#\m #\% #\d) 'percent-delta)
  (keymap-bind-key! *global-keymap* '(#\m #\% #\t) 'percent-t)

  (keymap-bind-new-keymap! *global-keymap* '(#\r) "Register >>")
  (keymap-bind-key! *global-keymap* '(#\r #\U) 'register-unwatch-all)
  (keymap-bind-key! *global-keymap* '(#\r #\u) 'register-unwatch)
  (keymap-bind-key! *global-keymap* '(#\r #\w) 'register-watch)
  (keymap-bind-key! *global-keymap* '(#\r #\x) 'register-exchange)
  (keymap-bind-key! *global-keymap* '(#\r #\r) 'register-evaluate)
  (keymap-bind-key! *global-keymap* '(#\r #\R) 'register-recall)
  (keymap-bind-key! *global-keymap* '(#\r #\s) 'register-store)

  (keymap-bind-key! *global-keymap* '((:control #\x)) 'stack-cut #f)
  (keymap-bind-key! *global-keymap* '((:control #\c)) 'stack-copy #f)
  (keymap-bind-key! *global-keymap* '((:control #\v)) 'stack-paste #f)

  (keymap-bind-key! *global-keymap* '(#\~) 'bitwise-not #f)
  (keymap-bind-key! *global-keymap* '(#\&) 'bitwise-and #f)
  (keymap-bind-key! *global-keymap* '(#\|) 'bitwise-or #f)
  (keymap-bind-key! *global-keymap* '(#\^) 'bitwise-xor #f)
  (keymap-bind-key! *global-keymap* '(#\<) 'bitwise-shl #f)
  (keymap-bind-key! *global-keymap* '(#\>) 'bitwise-shr #f)

  (keymap-bind-key! *global-keymap* '(#\+) '+ #f)
  (keymap-bind-key! *global-keymap* '(#\-) '- #f)
  (keymap-bind-key! *global-keymap* '(#\*) '* #f)
  (keymap-bind-key! *global-keymap* '(#\/) '/ #f)

  (keymap-bind-key! *global-keymap* '((:shift :key-escape)) 'sclear)
  (keymap-bind-key! *global-keymap* '((:shift :key-down)) 'srotd)
  (keymap-bind-key! *global-keymap* '((:shift :key-up)) 'srot)
  (keymap-bind-key! *global-keymap* '((:shift :key-return)) 'sdup2)
  (keymap-bind-key! *global-keymap* '(:key-return) 'sdup)
  (keymap-bind-key! *global-keymap* '((:shift :key-back)) 'sdropn)
 (keymap-bind-key! *global-keymap* '(:key-back) 'sdrop)
  (keymap-bind-key! *global-keymap* '(:key-tab) 'sswap)
  (keymap-bind-key! *global-keymap* '((:control #\a)) 'last-arguments)
  (keymap-bind-key! *global-keymap* '((:control #\y)) 'redo-stack)
  (keymap-bind-key! *global-keymap* '((:control #\z)) 'last-stack)
  (keymap-bind-key! *global-keymap* '(#\%) 'percent)
  (keymap-bind-key! *global-keymap* '(#\x) 'expt)
  (keymap-bind-key! *global-keymap* '(#\s) 'sqrt)
  (keymap-bind-key! *global-keymap* '(#\_) 'chs)
  (keymap-bind-key! *global-keymap* '(:key-space) 'chs #f)    
  (keymap-bind-key! *global-keymap* '(:key-f1) 'toggle-key-help)

  ; (keymap-bind-key! *global-keymap* '(#\@) 'show-console)
   
  (keymap-bind-key! *global-keymap* '(#\0) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\1) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\2) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\3) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\4) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\5) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\6) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\7) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\8) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\9) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\.) 'begin-editor-with-last-keystroke #f)
  (keymap-bind-key! *global-keymap* '(#\#) 'begin-editor-with-last-keystroke #f)

  *global-keymap*)


(define (make-keyspec-ftext keyspec binding)
  `("Arial" (18 (:bold ,keyspec) " - " ,binding)))

;;;
;;; Callbacks
;;;


(define (vcalc-stack-command-callback w cmd arg)
  ; The duplicate calls to save-persistant state are a side effect of the fact
  ; that the shutdown logic is pretty half-assed right now.  WM_CLOSE is
  ; posted on Alt-F4 and pressing the close box. :cmd-quit is posted by the
  ; quit menu. Since these are both fairly different code paths, we need to
  ; handle the persistance of calculator memory up here in the command
  ; processor. Truly hackish...
  (case cmd
    ((:cmd-window-close)
     (save-persistant-state))
    ((:cmd-quit)
     (save-persistant-state)
     (do-quit))
    ((:cmd-file-dropped)
     (load-state-from-file arg))
    ((:cmd-show-options)
     (do-config w))
    ((:cmd-register-vcalc)
     (do-register w))
    ((:cmd-about-vcalc)
     (about-box w))
    ((:cmd-load-state)
     (do-load/save-state w #t))
    ((:cmd-save-state)
     (do-load/save-state w #f))
    ((:cmd-toggle-keyboard-commands)
     (toggle-key-help))
    ((:cmd-showtip)
     (show-tip-of-the-day))
    ((:cmd-cut)
     (stack-apply stack-cut)
     (update-window *stack-window*))
    ((:cmd-copy)
     (stack-apply stack-copy)
     (update-window *stack-window*))
    ((:cmd-paste)
     (stack-apply stack-paste)
     (update-window *stack-window*))
    ((:cmd-laststack)
     (stack-apply last-stack)
     (update-window *stack-window*))
    ((:cmd-redostack)
     (stack-apply redo-stack)
     (update-window *stack-window*))))


  
(define (vcalc-stack-keypress-callback w key-info)
  (push-key! key-info)
  (let ((binding (current-key-binding)))
    (cond ((not binding)
	   (beep)
	   (reset-current-key-sequence!))
	  ((keymap? binding)
	   )
	  (#t
	   (catch-all
	    (interactively-evaluate-object binding))
	   (reset-current-key-sequence!)))
    (update-window *keyhelp-window*)
    (update-window *stack-window*)))

(define (draw-keyboard-help s)
  (with-vertical-box :fill :top-down

    ; Draw, top down, the current key sequence. This is a sort of map
    ; that tells the user how she got to the current set of key bindings. To
    ; distinguish it from the current key bindings, it is drawn in yellow on
    ; blue text.
    (let ((sequence-prefix '()))
      (for-each (lambda (key-info)
		  (set! sequence-prefix (append! sequence-prefix (list (car key-info))))
		  (let* ((key-id (car key-info))
			 (key-ftext (make-keyspec-ftext (describe-keyspec-or-id key-id)
							(describe-object (keymap-find-key 
									  *global-keymap* 
									  sequence-prefix)))))
		    (let ((ys (cdar (get-formatted-text-extent s key-ftext))))
		      (with-item :fill ys
			(set-color! s #(0.0 0.0 0.5))
			(draw-current-box s)
			(set-color! s #(1.0 1.0 0.0))
			(draw-anchored-text s 
					    (scheme:+ (current-box-x) 10)
					    (scheme:+ (current-box-y)
						      (/ (current-box-height) 2))
					    :w
					    key-ftext)))))
		(current-key-sequence)))


    ; The rest of the key help pane is occupied by a list of the currently
    ; available key bindings. These are printed in black on yellow text.
    (set-color! s #(1.0 1.0 0.9))
    (draw-current-box s)	    
    
    (set-foreground-color! s #(0.3 0.3 0.0))
    
    (let ((current-keymap (current-key-binding)))

      (when (keymap? current-keymap)
	; Formatted text descriptions of each key binding are cached in the
	; keymaps.
	(let ((descriptions (keymap-user-cache current-keymap)))
	  (when (null? descriptions)
	    (set! descriptions 
		  (keymap-map
		   (lambda (key-id binding binding-public?)
		     (if binding-public?
			 (make-keyspec-ftext (describe-keyspec-or-id key-id)
					     (describe-object binding))
			 '()))
		   current-keymap))
	    (set-keymap-user-cache! current-keymap descriptions))
	  (for-each (lambda (ftext)
		      (unless (null? ftext)
			(let ((ys (cdar (get-formatted-text-extent s ftext))))
			  (with-item :fill ys
			    (draw-anchored-text s 
						(scheme:+ (current-box-x) 10)
						(scheme:+ (current-box-y)
							  (/ (current-box-height) 2))
						:w
						ftext)))))
		    descriptions))))))

(define (vcalc-keyhelp-update-callback w)
  (with-window-draw-surface w s
    (with-window-geometry w
      (draw-keyboard-help s)))
  (flush-window w))

(define (vcalc-stack-update-callback w)
  (set-status-text! w 1 (angle-mode-text))
  (set-status-text! w 2 (default-base-text))

  ;(set-status-text! w 3 (interest-accrual-text))
  (set-status-text! w 3 (macro-recorder-text))


  (with-window-draw-surface w s
    (let ((line-dark #f))
      (with-window-geometry w
	    
	(with-horizontal-box :fill :right-to-left

	  (with-vertical-box :fill :top-down
	    (set-color! s #(0.2 0.2 0.2))
	    (draw-current-box s)
	    
	    (with-vertical-box :fill :top-down
	      
	      
	      (for-each 
	       (lambda (reg)
		 (let* ((ftext (list
				#f
				(string-append 
				 "r["
				 (number->string (inexact->exact reg))
				 "]=")
				(format-object (vector-ref *registers* reg))))
			(ys (cdar (get-formatted-text-extent s ftext))))
		   
		   
		   (with-item :fill ys
		     (set-color! s #(0.9 0.9 1.0))
		     (draw-current-box s)
		     (set-foreground-color! s #(0.0 0.0 0.0))
		     (draw-anchored-text s 
					 (scheme:+ (current-box-x)  10)
					 (current-box-y)
					 :nw
					 ftext))))
	       *register-watch-list*))
	    
	    (with-vertical-box :fill :bottom-up
	      (for-each 
	       (lambda (elem)
		 (if line-dark
		     (set-color! s #(0.9 0.9 0.9))
		     (set-color! s #(0.95 0.95 0.95)))
		 (set! line-dark (not line-dark))  
		 (let* ((ftext (format-object elem))
			(ys (cdar (get-formatted-text-extent s ftext))))
		   (with-item :fill ys
		     (draw-current-box s)
		     (set-background-color! s #(1 0 0))
		     (set-foreground-color! s #(0.0 0.0 0.0))
		     (draw-anchored-text s 
					 (scheme:- (scheme:+ (current-box-x) (current-box-width)) 10) 
					 (current-box-y)
					 :ne
					 ftext)
		     )))
	       *stack*)))))))
  (flush-window w))
   


(define (init-vcalc-stack-window)
  (let ((w #f)
	(d #f)
	(k *global-keymap*))k

    (set! w
	  (make-window 'vc-window '()

		       'initial-title
		       "vCalc"

		       'command-callback
		       (lambda (cmd arg) (vcalc-stack-command-callback w cmd arg))

		       'keypress-callback
		       (lambda key-info
			 (vcalc-stack-keypress-callback w key-info))

		       'size-callback
		       (lambda (x y) 
			 ; After the call to make-window, but before the set! is evaluated,
			 ; w = #f. Therefore, update-window will fail unless guarded for
			 ; that case.
			 (when w 
			   (update-window w)))

		       'update-callback
		       (lambda () (vcalc-stack-update-callback w))))

    (set! d
	  (make-window 'drawer w

		       'initial-title
		       "vCalc Keyboard Help"

		       'size-callback
		       (lambda (x y) 
			 ; After the call to make-window, but before the set! is evaluated,
			 ; d = #f. Therefore, update-window will fail unless guarded for
			 ; that case.
			 (when d
			   (update-window d)))

		       'update-callback
		       (lambda () (vcalc-keyhelp-update-callback d))))

    (set! *stack-window* w)
    (set! *keyhelp-window* d)

    (update-window w)
    (update-window d)

     w))

(define (vcalc-boot)
  (init-global-keymap)
  (init-vcalc-stack-window)
  (maybe-load-persistant-state)
  (show-window *stack-window*)
  (update-window *keyhelp-window*)
  (maybe-show-tip-of-the-day))

(set! *flonum-print-precision* 16)

(vcalc-boot)




